// --- Generated by AidaCxxStub ---
#ifndef __SRVT__aidacc_tests_t304_testpass_idl
#define __SRVT__aidacc_tests_t304_testpass_idl


// --- ServerHH Boilerplate ---
#include <aidacc/aida.hh>

#include <aidacc/aida.hh> // for rcore/signal.hh

#define AIDA_ENUM_DEFINE_ARITHMETIC_EQ(Enum)   \
  bool constexpr operator== (Enum v, int64_t n) { return int64_t (v) == n; } \
  bool constexpr operator== (int64_t n, Enum v) { return n == int64_t (v); } \
  bool constexpr operator!= (Enum v, int64_t n) { return int64_t (v) != n; } \
  bool constexpr operator!= (int64_t n, Enum v) { return n != int64_t (v); }
#define AIDA_FLAGS_DEFINE_ARITHMETIC_OPS(Enum)   \
  static constexpr int64_t operator>> (Enum v, int64_t n) { return int64_t (v) >> n; } \
  static constexpr int64_t operator<< (Enum v, int64_t n) { return int64_t (v) << n; } \
  static constexpr int64_t operator^  (Enum v, int64_t n) { return int64_t (v) ^ n; } \
  static constexpr int64_t operator^  (int64_t n, Enum v) { return n ^ int64_t (v); } \
  static constexpr Enum    operator^  (Enum v, Enum w)    { return Enum (int64_t (v) ^ w); } \
  static constexpr int64_t operator|  (Enum v, int64_t n) { return int64_t (v) | n; } \
  static constexpr int64_t operator|  (int64_t n, Enum v) { return n | int64_t (v); } \
  static constexpr Enum    operator|  (Enum v, Enum w)    { return Enum (int64_t (v) | w); } \
  static constexpr int64_t operator&  (Enum v, int64_t n) { return int64_t (v) & n; } \
  static constexpr int64_t operator&  (int64_t n, Enum v) { return n & int64_t (v); } \
  static constexpr Enum    operator&  (Enum v, Enum w)    { return Enum (int64_t (v) & w); } \
  static constexpr int64_t operator~  (Enum v)            { return ~int64_t (v); } \
  static constexpr int64_t operator+  (Enum v)            { return +int64_t (v); } \
  static constexpr int64_t operator-  (Enum v)            { return -int64_t (v); } \
  static constexpr int64_t operator+  (Enum v, int64_t n) { return int64_t (v) + n; } \
  static constexpr int64_t operator+  (int64_t n, Enum v) { return n + int64_t (v); } \
  static constexpr int64_t operator-  (Enum v, int64_t n) { return int64_t (v) - n; } \
  static constexpr int64_t operator-  (int64_t n, Enum v) { return n - int64_t (v); } \
  static constexpr int64_t operator*  (Enum v, int64_t n) { return int64_t (v) * n; } \
  static constexpr int64_t operator*  (int64_t n, Enum v) { return n * int64_t (v); } \
  static constexpr int64_t operator/  (Enum v, int64_t n) { return int64_t (v) / n; } \
  static constexpr int64_t operator/  (int64_t n, Enum v) { return n / int64_t (v); } \
  static constexpr int64_t operator%  (Enum v, int64_t n) { return int64_t (v) % n; } \
  static constexpr int64_t operator%  (int64_t n, Enum v) { return n % int64_t (v); } \
  RAPICORN_FIXCYTHON_ENUM (Enum)
#ifdef     CYTHON_COMPILING_IN_CPYTHON
// Use C++ ADL, so PyInt_FromLong as generated by Cython works on scoped enums.
#define RAPICORN_FIXCYTHON_ENUM(Enum) \
  extern inline PyObject* PyInt_FromLong (Enum __e_) { return ::PyInt_FromLong (long (__e_)); }
#else  // !CYTHON_COMPILING_IN_CPYTHON
#define RAPICORN_FIXCYTHON_ENUM(Enum)
#endif // !CYTHON_COMPILING_IN_CPYTHON
#ifdef     AIDA_ENABLE_ENUM_ARITHMETIC
#define AIDA_ENUM_DEFINE_ARITHMETIC_OPS        AIDA_FLAGS_DEFINE_ARITHMETIC_OPS
#else  // !AIDA_ENABLE_ENUM_ARITHMETIC
#define AIDA_ENUM_DEFINE_ARITHMETIC_OPS(Enum)  /* no arithmetic ops */
#endif // !AIDA_ENABLE_ENUM_ARITHMETIC

using IntrospectionRegistry = Aida::IntrospectionRegistry;

#ifndef __ENUMHH__aidacc_tests_t304_testpass_idl__
#define __ENUMHH__aidacc_tests_t304_testpass_idl__

namespace MandatoryNamespace {

/// @cond GeneratedEnums
enum class Enum1 : int64_t {
  E1_A = 1,
};
inline const char* operator->* (::Aida::IntrospectionTypename, Enum1) { return "MandatoryNamespace::Enum1"; }
inline void operator<<= (Aida::ProtoMsg &__p_,  Enum1  e) { __p_ <<= Aida::EnumValue (e); }
inline void operator>>= (Aida::ProtoReader &__f_, Enum1 &e) { e = Enum1 (__f_.pop_evalue()); }
AIDA_ENUM_DEFINE_ARITHMETIC_EQ (Enum1);
AIDA_ENUM_DEFINE_ARITHMETIC_OPS (Enum1);
/// @endcond

/// @cond GeneratedEnums
enum class Enum1c : int64_t {
  E1C_A = 1,
};
inline const char* operator->* (::Aida::IntrospectionTypename, Enum1c) { return "MandatoryNamespace::Enum1c"; }
inline void operator<<= (Aida::ProtoMsg &__p_,  Enum1c  e) { __p_ <<= Aida::EnumValue (e); }
inline void operator>>= (Aida::ProtoReader &__f_, Enum1c &e) { e = Enum1c (__f_.pop_evalue()); }
AIDA_ENUM_DEFINE_ARITHMETIC_EQ (Enum1c);
AIDA_ENUM_DEFINE_ARITHMETIC_OPS (Enum1c);
/// @endcond

/// @cond GeneratedEnums
enum class Enum2 : int64_t {
  E2_A = 1,
  E2_B = 2,
};
inline const char* operator->* (::Aida::IntrospectionTypename, Enum2) { return "MandatoryNamespace::Enum2"; }
inline void operator<<= (Aida::ProtoMsg &__p_,  Enum2  e) { __p_ <<= Aida::EnumValue (e); }
inline void operator>>= (Aida::ProtoReader &__f_, Enum2 &e) { e = Enum2 (__f_.pop_evalue()); }
AIDA_ENUM_DEFINE_ARITHMETIC_EQ (Enum2);
AIDA_ENUM_DEFINE_ARITHMETIC_OPS (Enum2);
/// @endcond

/// @cond GeneratedEnums
enum class Enum2c : int64_t {
  E2C_A = 1,
  E2C_B = 2,
};
inline const char* operator->* (::Aida::IntrospectionTypename, Enum2c) { return "MandatoryNamespace::Enum2c"; }
inline void operator<<= (Aida::ProtoMsg &__p_,  Enum2c  e) { __p_ <<= Aida::EnumValue (e); }
inline void operator>>= (Aida::ProtoReader &__f_, Enum2c &e) { e = Enum2c (__f_.pop_evalue()); }
AIDA_ENUM_DEFINE_ARITHMETIC_EQ (Enum2c);
AIDA_ENUM_DEFINE_ARITHMETIC_OPS (Enum2c);
/// @endcond

/// @cond GeneratedEnums
enum class Enum3 : int64_t {
  E3_A = 1,
  E3_B = 2,
  E3_C = 3,
};
inline const char* operator->* (::Aida::IntrospectionTypename, Enum3) { return "MandatoryNamespace::Enum3"; }
inline void operator<<= (Aida::ProtoMsg &__p_,  Enum3  e) { __p_ <<= Aida::EnumValue (e); }
inline void operator>>= (Aida::ProtoReader &__f_, Enum3 &e) { e = Enum3 (__f_.pop_evalue()); }
AIDA_ENUM_DEFINE_ARITHMETIC_EQ (Enum3);
AIDA_ENUM_DEFINE_ARITHMETIC_OPS (Enum3);
/// @endcond

/// @cond GeneratedEnums
enum class Enum3c : int64_t {
  E3C_A = 1,
  E3C_B = 2,
  E3C_C = 3,
};
inline const char* operator->* (::Aida::IntrospectionTypename, Enum3c) { return "MandatoryNamespace::Enum3c"; }
inline void operator<<= (Aida::ProtoMsg &__p_,  Enum3c  e) { __p_ <<= Aida::EnumValue (e); }
inline void operator>>= (Aida::ProtoReader &__f_, Enum3c &e) { e = Enum3c (__f_.pop_evalue()); }
AIDA_ENUM_DEFINE_ARITHMETIC_EQ (Enum3c);
AIDA_ENUM_DEFINE_ARITHMETIC_OPS (Enum3c);
/// @endcond

/// @cond GeneratedEnums
enum class Enum4a : int64_t {
  E4A_A = 1,
  E4A_B = 2,
  E4A_C = 3,
  E4A_D = 4,
};
inline const char* operator->* (::Aida::IntrospectionTypename, Enum4a) { return "MandatoryNamespace::Enum4a"; }
inline void operator<<= (Aida::ProtoMsg &__p_,  Enum4a  e) { __p_ <<= Aida::EnumValue (e); }
inline void operator>>= (Aida::ProtoReader &__f_, Enum4a &e) { e = Enum4a (__f_.pop_evalue()); }
AIDA_ENUM_DEFINE_ARITHMETIC_EQ (Enum4a);
AIDA_ENUM_DEFINE_ARITHMETIC_OPS (Enum4a);
/// @endcond

/// @cond GeneratedEnums
enum class Enum4b : int64_t {
  E4B_A = 1,
  E4B_B = 2,
  E4B_C = 3,
  E4B_D = 4,
};
inline const char* operator->* (::Aida::IntrospectionTypename, Enum4b) { return "MandatoryNamespace::Enum4b"; }
inline void operator<<= (Aida::ProtoMsg &__p_,  Enum4b  e) { __p_ <<= Aida::EnumValue (e); }
inline void operator>>= (Aida::ProtoReader &__f_, Enum4b &e) { e = Enum4b (__f_.pop_evalue()); }
AIDA_ENUM_DEFINE_ARITHMETIC_EQ (Enum4b);
AIDA_ENUM_DEFINE_ARITHMETIC_OPS (Enum4b);
/// @endcond

/// @cond GeneratedEnums
enum class Enum4c : int64_t {
  E4C_A = 1,
  E4C_B = 2,
  E4C_C = 3,
  E4C_D = 4,
};
inline const char* operator->* (::Aida::IntrospectionTypename, Enum4c) { return "MandatoryNamespace::Enum4c"; }
inline void operator<<= (Aida::ProtoMsg &__p_,  Enum4c  e) { __p_ <<= Aida::EnumValue (e); }
inline void operator>>= (Aida::ProtoReader &__f_, Enum4c &e) { e = Enum4c (__f_.pop_evalue()); }
AIDA_ENUM_DEFINE_ARITHMETIC_EQ (Enum4c);
AIDA_ENUM_DEFINE_ARITHMETIC_OPS (Enum4c);
/// @endcond

/// @cond GeneratedEnums
enum class Enum4d : int64_t {
  E4D_A = 1,
  E4D_B = 2,
  E4D_C = 3,
  E4D_D = 4,
};
inline const char* operator->* (::Aida::IntrospectionTypename, Enum4d) { return "MandatoryNamespace::Enum4d"; }
inline void operator<<= (Aida::ProtoMsg &__p_,  Enum4d  e) { __p_ <<= Aida::EnumValue (e); }
inline void operator>>= (Aida::ProtoReader &__f_, Enum4d &e) { e = Enum4d (__f_.pop_evalue()); }
AIDA_ENUM_DEFINE_ARITHMETIC_EQ (Enum4d);
AIDA_ENUM_DEFINE_ARITHMETIC_OPS (Enum4d);
/// @endcond

/// @cond GeneratedEnums
enum class ExtensiveEnum : int64_t {
  V1a = 1,
  V1b = 1,
  V2 = 2,
  V3 = 3,
  V4 = 4,
  V5 = 5, // "V5"
  V6 = 6, // "V6"
  V7 = 7, // _("V7")
  V8 = 8, // _("V8")
  V9 = 9,
  V10 = 10,
  V11 = 11,
  V12 = 12,
  V13 = 13,
  V14 = 14,
  V15 = 15, // "V15"
  V16 = 16, // "V16"
  V17 = 17, // _("V17")
  V18 = 18, // _("V18")
  V20 = 20,
  V21 = 21,
  V22 = 22,
  V23 = 23,
  V24 = 24,
  V25 = (-9223372036854775807 - 1),
  V26 = 9223372036854775807,
  V27 = 9223372036854775807,
  V28 = -28,
  V30 = 42,
  V31 = 43,
  V32 = 42,
  V33 = 43,
  V34 = 44, // "foo"
  V35 = 42,
  V36 = 42, // "foo4"
};
inline const char* operator->* (::Aida::IntrospectionTypename, ExtensiveEnum) { return "MandatoryNamespace::ExtensiveEnum"; }
inline void operator<<= (Aida::ProtoMsg &__p_,  ExtensiveEnum  e) { __p_ <<= Aida::EnumValue (e); }
inline void operator>>= (Aida::ProtoReader &__f_, ExtensiveEnum &e) { e = ExtensiveEnum (__f_.pop_evalue()); }
AIDA_ENUM_DEFINE_ARITHMETIC_EQ (ExtensiveEnum);
AIDA_ENUM_DEFINE_ARITHMETIC_OPS (ExtensiveEnum);
/// @endcond
} // MandatoryNamespace

namespace InterfaceTests {

/// @cond GeneratedEnums
enum class QuickEnum : int64_t {
  ZERO = 0,
};
inline const char* operator->* (::Aida::IntrospectionTypename, QuickEnum) { return "InterfaceTests::QuickEnum"; }
inline void operator<<= (Aida::ProtoMsg &__p_,  QuickEnum  e) { __p_ <<= Aida::EnumValue (e); }
inline void operator>>= (Aida::ProtoReader &__f_, QuickEnum &e) { e = QuickEnum (__f_.pop_evalue()); }
AIDA_ENUM_DEFINE_ARITHMETIC_EQ (QuickEnum);
AIDA_ENUM_DEFINE_ARITHMETIC_OPS (QuickEnum);
/// @endcond
} // InterfaceTests

namespace RapicornAidaTest {

/// @cond GeneratedEnums
enum class ClickType : int64_t {
  CLICK_ON_PRESS = 1,
  CLICK_ON_RELEASE = 2,
  CLICK_SLOW_REPEAT = 3,
  CLICK_FAST_REPEAT = 4,
  CLICK_KEY_REPEAT = 5,
};
inline const char* operator->* (::Aida::IntrospectionTypename, ClickType) { return "RapicornAidaTest::ClickType"; }
inline void operator<<= (Aida::ProtoMsg &__p_,  ClickType  e) { __p_ <<= Aida::EnumValue (e); }
inline void operator>>= (Aida::ProtoReader &__f_, ClickType &e) { e = ClickType (__f_.pop_evalue()); }
AIDA_ENUM_DEFINE_ARITHMETIC_EQ (ClickType);
AIDA_ENUM_DEFINE_ARITHMETIC_OPS (ClickType);
/// @endcond

/// @cond GeneratedEnums
enum class MathExpressions : int64_t {
  RESULT_2 = 2,
  RESULT_5 = 5,
  RESULT_8 = 8,
  RESULT_6 = 6,
  RESULT_7 = 7,
  RESULT_16 = 16,
  RESULT_3 = 3,
  RESULT_24 = 24,
  RESULT_13 = 13,
  RESULT_m2 = -2,
  RESULT_77 = 77,
  RESULT_511 = 511,
};
inline const char* operator->* (::Aida::IntrospectionTypename, MathExpressions) { return "RapicornAidaTest::MathExpressions"; }
inline void operator<<= (Aida::ProtoMsg &__p_,  MathExpressions  e) { __p_ <<= Aida::EnumValue (e); }
inline void operator>>= (Aida::ProtoReader &__f_, MathExpressions &e) { e = MathExpressions (__f_.pop_evalue()); }
AIDA_ENUM_DEFINE_ARITHMETIC_EQ (MathExpressions);
AIDA_ENUM_DEFINE_ARITHMETIC_OPS (MathExpressions);
/// @endcond
} // RapicornAidaTest

namespace Aida {
template<> const EnumInfo& enum_info<MandatoryNamespace::Enum1> ();
template<> const EnumInfo& enum_info<MandatoryNamespace::Enum1c> ();
template<> const EnumInfo& enum_info<MandatoryNamespace::Enum2> ();
template<> const EnumInfo& enum_info<MandatoryNamespace::Enum2c> ();
template<> const EnumInfo& enum_info<MandatoryNamespace::Enum3> ();
template<> const EnumInfo& enum_info<MandatoryNamespace::Enum3c> ();
template<> const EnumInfo& enum_info<MandatoryNamespace::Enum4a> ();
template<> const EnumInfo& enum_info<MandatoryNamespace::Enum4b> ();
template<> const EnumInfo& enum_info<MandatoryNamespace::Enum4c> ();
template<> const EnumInfo& enum_info<MandatoryNamespace::Enum4d> ();
template<> const EnumInfo& enum_info<MandatoryNamespace::ExtensiveEnum> ();
template<> const EnumInfo& enum_info<InterfaceTests::QuickEnum> ();
template<> const EnumInfo& enum_info<RapicornAidaTest::ClickType> ();
template<> const EnumInfo& enum_info<RapicornAidaTest::MathExpressions> ();
} // Aida

#endif // __ENUMHH__aidacc_tests_t304_testpass_idl__


// --- Interfaces (class declarations) ---

namespace MandatoryNamespace {

class I_FirstInterfaceIface;
typedef std::shared_ptr<I_FirstInterfaceIface> I_FirstInterfaceIfaceP;
typedef std::weak_ptr  <I_FirstInterfaceIface> I_FirstInterfaceIfaceW;

class I_FirstInterfaceIface : public virtual Aida::ImplicitBase
{
protected:
  explicit                              I_FirstInterfaceIface ();
  virtual  /*dtor*/                    ~I_FirstInterfaceIface () override = 0;
public:
  virtual Aida::TypeHashList            __aida_typelist__  () const override;
  virtual std::string                   __typename__       () const override	{ return "MandatoryNamespace::FirstInterface"; }
  virtual const Aida::StringVector&     __aida_aux_data__  () const override;
  virtual std::vector<std::string>      __aida_dir__       () const override;
  virtual Aida::Any                     __aida_get__       (const std::string &name) const override;
  virtual bool                          __aida_set__       (const std::string &name, const Aida::Any &any) override;
  virtual void                          void_func             () = 0;
  template<class Visitor> void  __accept_accessor__ (Visitor &__visitor_)
  {}
};
void operator<<= (Aida::ProtoMsg&, const I_FirstInterfaceIfaceP&);
void operator>>= (Aida::ProtoReader&, I_FirstInterfaceIface*&);
void operator>>= (Aida::ProtoReader&, I_FirstInterfaceIfaceP&);

class SrvT_XFooRecord
{
public:
  /// @cond GeneratedFields
  bool                          single_bool;
  int                           single_num;
  int64_t                       num64;
  double                        single_float;
  std::string                   single_string;
  int                           sibling1;
  int                           sibling2;
  int                           multi1;
  int                           multi2;
  int                           multi3;
  int                           multi4;
  ExtensiveEnum                 enum_field;
  I_FirstInterfaceIfaceP        iface1;
  I_FirstInterfaceIfaceP        iface2;
  I_FirstInterfaceIfaceP        iface3;
  Aida::Any                     any1;
  Aida::Any                     any2;
  Aida::Any                     any3;
  /// @endcond
  inline                        SrvT_XFooRecord () { single_bool = 0; single_num = 0; num64 = 0; single_float = 0; sibling1 = 0; sibling2 = 0; multi1 = 0; multi2 = 0; multi3 = 0; multi4 = 0; enum_field = ExtensiveEnum (0); }
  inline                        SrvT_XFooRecord (const Aida::AnyDict &ad) : SrvT_XFooRecord() { __aida_from_any__ (Aida::Any (ad)); }
  std::string                   __typename__      () const	{ return "MandatoryNamespace::XFooRecord"; }
  const Aida::StringVector&     __aida_aux_data__ () const;
  Aida::Any                     __aida_to_any__   () { return Aida::any_from_visitable (*this); }
  void                          __aida_from_any__ (const Aida::Any &any) { return Aida::any_to_visitable (any, *this); }
  operator                      Aida::AnyDict     () const { return const_cast<SrvT_XFooRecord*> (this)->__aida_to_any__().get<Aida::AnyDict>(); }
  bool                          operator==  (const SrvT_XFooRecord &other) const;
  bool                          operator!=  (const SrvT_XFooRecord &other) const { return !operator== (other); }
  template<class Visitor> void  __accept__  (Visitor &_visitor_)
  {
    _visitor_ (single_bool, "single_bool");
    _visitor_ (single_num, "single_num");
    _visitor_ (num64, "num64");
    _visitor_ (single_float, "single_float");
    _visitor_ (single_string, "single_string");
    _visitor_ (sibling1, "sibling1");
    _visitor_ (sibling2, "sibling2");
    _visitor_ (multi1, "multi1");
    _visitor_ (multi2, "multi2");
    _visitor_ (multi3, "multi3");
    _visitor_ (multi4, "multi4");
    _visitor_ (enum_field, "enum_field");
    _visitor_ (iface1, "iface1");
    _visitor_ (iface2, "iface2");
    _visitor_ (iface3, "iface3");
    _visitor_ (any1, "any1");
    _visitor_ (any2, "any2");
    _visitor_ (any3, "any3");
  }
};
void operator<<= (Aida::ProtoMsg&, const SrvT_XFooRecord&);
void operator>>= (Aida::ProtoReader&, SrvT_XFooRecord&);

class SrvT_XFooSequence : public std::vector<bool>
{
public:
  typedef std::vector<bool> Sequence;
  reference append_back() ///< Append data at the end, returns write reference to data.
  { resize (size() + 1); return back(); }
  explicit                      SrvT_XFooSequence (std::initializer_list<value_type> il) : Sequence (il) {};
  inline                        SrvT_XFooSequence () = default;
  inline                        SrvT_XFooSequence (const Aida::AnyList &al) : SrvT_XFooSequence() { __aida_from_any__ (Aida::Any (al)); }
  std::string                   __typename__      () const	{ return "MandatoryNamespace::XFooSequence"; }
  const Aida::StringVector&     __aida_aux_data__ () const;
  Aida::Any                     __aida_to_any__   () { return Aida::any_from_sequence (*this); }
  void                          __aida_from_any__ (const Aida::Any &any) { return Aida::any_to_sequence (any, *this); }
  operator                      Aida::AnyList     () const { return const_cast<SrvT_XFooSequence*> (this)->__aida_to_any__().get<Aida::AnyList>(); }
};
void operator<<= (Aida::ProtoMsg&, const SrvT_XFooSequence&);
void operator>>= (Aida::ProtoReader&, SrvT_XFooSequence&);

class SrvT_IntSequence : public std::vector<int>
{
public:
  typedef std::vector<int> Sequence;
  reference append_back() ///< Append data at the end, returns write reference to data.
  { resize (size() + 1); return back(); }
  explicit                      SrvT_IntSequence (std::initializer_list<value_type> il) : Sequence (il) {};
  inline                        SrvT_IntSequence () = default;
  inline                        SrvT_IntSequence (const Aida::AnyList &al) : SrvT_IntSequence() { __aida_from_any__ (Aida::Any (al)); }
  std::string                   __typename__      () const	{ return "MandatoryNamespace::IntSequence"; }
  const Aida::StringVector&     __aida_aux_data__ () const;
  Aida::Any                     __aida_to_any__   () { return Aida::any_from_sequence (*this); }
  void                          __aida_from_any__ (const Aida::Any &any) { return Aida::any_to_sequence (any, *this); }
  operator                      Aida::AnyList     () const { return const_cast<SrvT_IntSequence*> (this)->__aida_to_any__().get<Aida::AnyList>(); }
};
void operator<<= (Aida::ProtoMsg&, const SrvT_IntSequence&);
void operator>>= (Aida::ProtoReader&, SrvT_IntSequence&);

class SrvT_FloatSequence : public std::vector<double>
{
public:
  typedef std::vector<double> Sequence;
  reference append_back() ///< Append data at the end, returns write reference to data.
  { resize (size() + 1); return back(); }
  explicit                      SrvT_FloatSequence (std::initializer_list<value_type> il) : Sequence (il) {};
  inline                        SrvT_FloatSequence () = default;
  inline                        SrvT_FloatSequence (const Aida::AnyList &al) : SrvT_FloatSequence() { __aida_from_any__ (Aida::Any (al)); }
  std::string                   __typename__      () const	{ return "MandatoryNamespace::FloatSequence"; }
  const Aida::StringVector&     __aida_aux_data__ () const;
  Aida::Any                     __aida_to_any__   () { return Aida::any_from_sequence (*this); }
  void                          __aida_from_any__ (const Aida::Any &any) { return Aida::any_to_sequence (any, *this); }
  operator                      Aida::AnyList     () const { return const_cast<SrvT_FloatSequence*> (this)->__aida_to_any__().get<Aida::AnyList>(); }
};
void operator<<= (Aida::ProtoMsg&, const SrvT_FloatSequence&);
void operator>>= (Aida::ProtoReader&, SrvT_FloatSequence&);

class SrvT_StringSequence : public std::vector<std::string>
{
public:
  typedef std::vector<std::string> Sequence;
  reference append_back() ///< Append data at the end, returns write reference to data.
  { resize (size() + 1); return back(); }
  explicit                      SrvT_StringSequence (std::initializer_list<value_type> il) : Sequence (il) {};
  inline                        SrvT_StringSequence () = default;
  inline                        SrvT_StringSequence (const Aida::AnyList &al) : SrvT_StringSequence() { __aida_from_any__ (Aida::Any (al)); }
  std::string                   __typename__      () const	{ return "MandatoryNamespace::StringSequence"; }
  const Aida::StringVector&     __aida_aux_data__ () const;
  Aida::Any                     __aida_to_any__   () { return Aida::any_from_sequence (*this); }
  void                          __aida_from_any__ (const Aida::Any &any) { return Aida::any_to_sequence (any, *this); }
  operator                      Aida::AnyList     () const { return const_cast<SrvT_StringSequence*> (this)->__aida_to_any__().get<Aida::AnyList>(); }
};
void operator<<= (Aida::ProtoMsg&, const SrvT_StringSequence&);
void operator>>= (Aida::ProtoReader&, SrvT_StringSequence&);

class SrvT_ExtensiveEnumSequence : public std::vector<ExtensiveEnum>
{
public:
  typedef std::vector<ExtensiveEnum> Sequence;
  reference append_back() ///< Append data at the end, returns write reference to data.
  { resize (size() + 1); return back(); }
  explicit                      SrvT_ExtensiveEnumSequence (std::initializer_list<value_type> il) : Sequence (il) {};
  inline                        SrvT_ExtensiveEnumSequence () = default;
  inline                        SrvT_ExtensiveEnumSequence (const Aida::AnyList &al) : SrvT_ExtensiveEnumSequence() { __aida_from_any__ (Aida::Any (al)); }
  std::string                   __typename__      () const	{ return "MandatoryNamespace::ExtensiveEnumSequence"; }
  const Aida::StringVector&     __aida_aux_data__ () const;
  Aida::Any                     __aida_to_any__   () { return Aida::any_from_sequence (*this); }
  void                          __aida_from_any__ (const Aida::Any &any) { return Aida::any_to_sequence (any, *this); }
  operator                      Aida::AnyList     () const { return const_cast<SrvT_ExtensiveEnumSequence*> (this)->__aida_to_any__().get<Aida::AnyList>(); }
};
void operator<<= (Aida::ProtoMsg&, const SrvT_ExtensiveEnumSequence&);
void operator>>= (Aida::ProtoReader&, SrvT_ExtensiveEnumSequence&);

class SrvT_RecordSequence : public std::vector<SrvT_XFooRecord>
{
public:
  typedef std::vector<SrvT_XFooRecord> Sequence;
  reference append_back() ///< Append data at the end, returns write reference to data.
  { resize (size() + 1); return back(); }
  explicit                      SrvT_RecordSequence (std::initializer_list<value_type> il) : Sequence (il) {};
  inline                        SrvT_RecordSequence () = default;
  inline                        SrvT_RecordSequence (const Aida::AnyList &al) : SrvT_RecordSequence() { __aida_from_any__ (Aida::Any (al)); }
  std::string                   __typename__      () const	{ return "MandatoryNamespace::RecordSequence"; }
  const Aida::StringVector&     __aida_aux_data__ () const;
  Aida::Any                     __aida_to_any__   () { return Aida::any_from_sequence (*this); }
  void                          __aida_from_any__ (const Aida::Any &any) { return Aida::any_to_sequence (any, *this); }
  operator                      Aida::AnyList     () const { return const_cast<SrvT_RecordSequence*> (this)->__aida_to_any__().get<Aida::AnyList>(); }
};
void operator<<= (Aida::ProtoMsg&, const SrvT_RecordSequence&);
void operator>>= (Aida::ProtoReader&, SrvT_RecordSequence&);

class SrvT_SequenceSequence : public std::vector<SrvT_IntSequence>
{
public:
  typedef std::vector<SrvT_IntSequence> Sequence;
  reference append_back() ///< Append data at the end, returns write reference to data.
  { resize (size() + 1); return back(); }
  explicit                      SrvT_SequenceSequence (std::initializer_list<value_type> il) : Sequence (il) {};
  inline                        SrvT_SequenceSequence () = default;
  inline                        SrvT_SequenceSequence (const Aida::AnyList &al) : SrvT_SequenceSequence() { __aida_from_any__ (Aida::Any (al)); }
  std::string                   __typename__      () const	{ return "MandatoryNamespace::SequenceSequence"; }
  const Aida::StringVector&     __aida_aux_data__ () const;
  Aida::Any                     __aida_to_any__   () { return Aida::any_from_sequence (*this); }
  void                          __aida_from_any__ (const Aida::Any &any) { return Aida::any_to_sequence (any, *this); }
  operator                      Aida::AnyList     () const { return const_cast<SrvT_SequenceSequence*> (this)->__aida_to_any__().get<Aida::AnyList>(); }
};
void operator<<= (Aida::ProtoMsg&, const SrvT_SequenceSequence&);
void operator>>= (Aida::ProtoReader&, SrvT_SequenceSequence&);

class SrvT_InterfaceSequence : public std::vector<I_FirstInterfaceIfaceP>
{
public:
  typedef std::vector<I_FirstInterfaceIfaceP> Sequence;
  reference append_back() ///< Append data at the end, returns write reference to data.
  { resize (size() + 1); return back(); }
  explicit                      SrvT_InterfaceSequence (std::initializer_list<value_type> il) : Sequence (il) {};
  inline                        SrvT_InterfaceSequence () = default;
  inline                        SrvT_InterfaceSequence (const Aida::AnyList &al) : SrvT_InterfaceSequence() { __aida_from_any__ (Aida::Any (al)); }
  std::string                   __typename__      () const	{ return "MandatoryNamespace::InterfaceSequence"; }
  const Aida::StringVector&     __aida_aux_data__ () const;
  Aida::Any                     __aida_to_any__   () { return Aida::any_from_sequence (*this); }
  void                          __aida_from_any__ (const Aida::Any &any) { return Aida::any_to_sequence (any, *this); }
  operator                      Aida::AnyList     () const { return const_cast<SrvT_InterfaceSequence*> (this)->__aida_to_any__().get<Aida::AnyList>(); }
};
void operator<<= (Aida::ProtoMsg&, const SrvT_InterfaceSequence&);
void operator>>= (Aida::ProtoReader&, SrvT_InterfaceSequence&);

class SrvT_AnySequence : public std::vector<Aida::Any>
{
public:
  typedef std::vector<Aida::Any> Sequence;
  reference append_back() ///< Append data at the end, returns write reference to data.
  { resize (size() + 1); return back(); }
  explicit                      SrvT_AnySequence (std::initializer_list<value_type> il) : Sequence (il) {};
  inline                        SrvT_AnySequence () = default;
  inline                        SrvT_AnySequence (const Aida::AnyList &al) : SrvT_AnySequence() { __aida_from_any__ (Aida::Any (al)); }
  std::string                   __typename__      () const	{ return "MandatoryNamespace::AnySequence"; }
  const Aida::StringVector&     __aida_aux_data__ () const;
  Aida::Any                     __aida_to_any__   () { return Aida::any_from_sequence (*this); }
  void                          __aida_from_any__ (const Aida::Any &any) { return Aida::any_to_sequence (any, *this); }
  operator                      Aida::AnyList     () const { return const_cast<SrvT_AnySequence*> (this)->__aida_to_any__().get<Aida::AnyList>(); }
};
void operator<<= (Aida::ProtoMsg&, const SrvT_AnySequence&);
void operator>>= (Aida::ProtoReader&, SrvT_AnySequence&);

class SrvT_NestedTypesRec;

class SrvT_NestedTypesSeq;

class SrvT_NestedTypesRec
{
public:
  /// @cond GeneratedFields
  SrvT_XFooRecord               rec;
  SrvT_XFooSequence             seq;
  /// @endcond
  inline                        SrvT_NestedTypesRec () { }
  inline                        SrvT_NestedTypesRec (const Aida::AnyDict &ad) : SrvT_NestedTypesRec() { __aida_from_any__ (Aida::Any (ad)); }
  std::string                   __typename__      () const	{ return "MandatoryNamespace::NestedTypesRec"; }
  const Aida::StringVector&     __aida_aux_data__ () const;
  Aida::Any                     __aida_to_any__   () { return Aida::any_from_visitable (*this); }
  void                          __aida_from_any__ (const Aida::Any &any) { return Aida::any_to_visitable (any, *this); }
  operator                      Aida::AnyDict     () const { return const_cast<SrvT_NestedTypesRec*> (this)->__aida_to_any__().get<Aida::AnyDict>(); }
  bool                          operator==  (const SrvT_NestedTypesRec &other) const;
  bool                          operator!=  (const SrvT_NestedTypesRec &other) const { return !operator== (other); }
  template<class Visitor> void  __accept__  (Visitor &_visitor_)
  {
    _visitor_ (rec, "rec");
    _visitor_ (seq, "seq");
  }
};
void operator<<= (Aida::ProtoMsg&, const SrvT_NestedTypesRec&);
void operator>>= (Aida::ProtoReader&, SrvT_NestedTypesRec&);

class SrvT_NestedTypesSeq : public std::vector<SrvT_NestedTypesRec>
{
public:
  typedef std::vector<SrvT_NestedTypesRec> Sequence;
  reference append_back() ///< Append data at the end, returns write reference to data.
  { resize (size() + 1); return back(); }
  explicit                      SrvT_NestedTypesSeq (std::initializer_list<value_type> il) : Sequence (il) {};
  inline                        SrvT_NestedTypesSeq () = default;
  inline                        SrvT_NestedTypesSeq (const Aida::AnyList &al) : SrvT_NestedTypesSeq() { __aida_from_any__ (Aida::Any (al)); }
  std::string                   __typename__      () const	{ return "MandatoryNamespace::NestedTypesSeq"; }
  const Aida::StringVector&     __aida_aux_data__ () const;
  Aida::Any                     __aida_to_any__   () { return Aida::any_from_sequence (*this); }
  void                          __aida_from_any__ (const Aida::Any &any) { return Aida::any_to_sequence (any, *this); }
  operator                      Aida::AnyList     () const { return const_cast<SrvT_NestedTypesSeq*> (this)->__aida_to_any__().get<Aida::AnyList>(); }
};
void operator<<= (Aida::ProtoMsg&, const SrvT_NestedTypesSeq&);
void operator>>= (Aida::ProtoReader&, SrvT_NestedTypesSeq&);

class SrvT_NewRecord
{
public:
  /// @cond GeneratedFields
  int                           i;
  Enum1                         enum1;
  SrvT_XFooSequence             xfs;
  SrvT_NestedTypesRec           ntr;
  /// @endcond
  inline                        SrvT_NewRecord () { i = 0; enum1 = Enum1 (0); }
  inline                        SrvT_NewRecord (const Aida::AnyDict &ad) : SrvT_NewRecord() { __aida_from_any__ (Aida::Any (ad)); }
  std::string                   __typename__      () const	{ return "MandatoryNamespace::NewRecord"; }
  const Aida::StringVector&     __aida_aux_data__ () const;
  Aida::Any                     __aida_to_any__   () { return Aida::any_from_visitable (*this); }
  void                          __aida_from_any__ (const Aida::Any &any) { return Aida::any_to_visitable (any, *this); }
  operator                      Aida::AnyDict     () const { return const_cast<SrvT_NewRecord*> (this)->__aida_to_any__().get<Aida::AnyDict>(); }
  bool                          operator==  (const SrvT_NewRecord &other) const;
  bool                          operator!=  (const SrvT_NewRecord &other) const { return !operator== (other); }
  template<class Visitor> void  __accept__  (Visitor &_visitor_)
  {
    _visitor_ (i, "i");
    _visitor_ (enum1, "enum1");
    _visitor_ (xfs, "xfs");
    _visitor_ (ntr, "ntr");
  }
};
void operator<<= (Aida::ProtoMsg&, const SrvT_NewRecord&);
void operator>>= (Aida::ProtoReader&, SrvT_NewRecord&);

namespace Inner {

class SrvT_InnerRecord
{
public:
  /// @cond GeneratedFields
  int                           x;
  int                           y;
  SrvT_NewRecord                rec;
  /// @endcond
  inline                        SrvT_InnerRecord () { x = 0; y = 0; }
  inline                        SrvT_InnerRecord (const Aida::AnyDict &ad) : SrvT_InnerRecord() { __aida_from_any__ (Aida::Any (ad)); }
  std::string                   __typename__      () const	{ return "MandatoryNamespace::Inner::InnerRecord"; }
  const Aida::StringVector&     __aida_aux_data__ () const;
  Aida::Any                     __aida_to_any__   () { return Aida::any_from_visitable (*this); }
  void                          __aida_from_any__ (const Aida::Any &any) { return Aida::any_to_visitable (any, *this); }
  operator                      Aida::AnyDict     () const { return const_cast<SrvT_InnerRecord*> (this)->__aida_to_any__().get<Aida::AnyDict>(); }
  bool                          operator==  (const SrvT_InnerRecord &other) const;
  bool                          operator!=  (const SrvT_InnerRecord &other) const { return !operator== (other); }
  template<class Visitor> void  __accept__  (Visitor &_visitor_)
  {
    _visitor_ (x, "x");
    _visitor_ (y, "y");
    _visitor_ (rec, "rec");
  }
};
void operator<<= (Aida::ProtoMsg&, const SrvT_InnerRecord&);
void operator>>= (Aida::ProtoReader&, SrvT_InnerRecord&);
} // Inner

class SrvT_Refer2Inner
{
public:
  /// @cond GeneratedFields
  Inner::SrvT_InnerRecord       r;
  /// @endcond
  inline                        SrvT_Refer2Inner () { }
  inline                        SrvT_Refer2Inner (const Aida::AnyDict &ad) : SrvT_Refer2Inner() { __aida_from_any__ (Aida::Any (ad)); }
  std::string                   __typename__      () const	{ return "MandatoryNamespace::Refer2Inner"; }
  const Aida::StringVector&     __aida_aux_data__ () const;
  Aida::Any                     __aida_to_any__   () { return Aida::any_from_visitable (*this); }
  void                          __aida_from_any__ (const Aida::Any &any) { return Aida::any_to_visitable (any, *this); }
  operator                      Aida::AnyDict     () const { return const_cast<SrvT_Refer2Inner*> (this)->__aida_to_any__().get<Aida::AnyDict>(); }
  bool                          operator==  (const SrvT_Refer2Inner &other) const;
  bool                          operator!=  (const SrvT_Refer2Inner &other) const { return !operator== (other); }
  template<class Visitor> void  __accept__  (Visitor &_visitor_)
  {
    _visitor_ (r, "r");
  }
};
void operator<<= (Aida::ProtoMsg&, const SrvT_Refer2Inner&);
void operator>>= (Aida::ProtoReader&, SrvT_Refer2Inner&);
} // MandatoryNamespace

namespace OtherNamespace {

class SrvT_SomeRecord
{
public:
  /// @cond GeneratedFields
  MandatoryNamespace::SrvT_NewRecord r1;
  MandatoryNamespace::SrvT_NewRecord r2;
  MandatoryNamespace::Inner::SrvT_InnerRecord r3;
  MandatoryNamespace::Inner::SrvT_InnerRecord r4;
  /// @endcond
  inline                        SrvT_SomeRecord () { }
  inline                        SrvT_SomeRecord (const Aida::AnyDict &ad) : SrvT_SomeRecord() { __aida_from_any__ (Aida::Any (ad)); }
  std::string                   __typename__      () const	{ return "OtherNamespace::SomeRecord"; }
  const Aida::StringVector&     __aida_aux_data__ () const;
  Aida::Any                     __aida_to_any__   () { return Aida::any_from_visitable (*this); }
  void                          __aida_from_any__ (const Aida::Any &any) { return Aida::any_to_visitable (any, *this); }
  operator                      Aida::AnyDict     () const { return const_cast<SrvT_SomeRecord*> (this)->__aida_to_any__().get<Aida::AnyDict>(); }
  bool                          operator==  (const SrvT_SomeRecord &other) const;
  bool                          operator!=  (const SrvT_SomeRecord &other) const { return !operator== (other); }
  template<class Visitor> void  __accept__  (Visitor &_visitor_)
  {
    _visitor_ (r1, "r1");
    _visitor_ (r2, "r2");
    _visitor_ (r3, "r3");
    _visitor_ (r4, "r4");
  }
};
void operator<<= (Aida::ProtoMsg&, const SrvT_SomeRecord&);
void operator>>= (Aida::ProtoReader&, SrvT_SomeRecord&);
} // OtherNamespace

namespace Auxdata {

class SrvT_RecordWithAuxdata
{
public:
  /// @cond GeneratedFields
  bool                          aux_bool;
  int                           aux32;
  int64_t                       aux64;
  double                        auxf64;
  std::string                   aux_str;
  /// @endcond
  inline                        SrvT_RecordWithAuxdata () { aux_bool = 0; aux32 = 0; aux64 = 0; auxf64 = 0; }
  inline                        SrvT_RecordWithAuxdata (const Aida::AnyDict &ad) : SrvT_RecordWithAuxdata() { __aida_from_any__ (Aida::Any (ad)); }
  std::string                   __typename__      () const	{ return "Auxdata::RecordWithAuxdata"; }
  const Aida::StringVector&     __aida_aux_data__ () const;
  Aida::Any                     __aida_to_any__   () { return Aida::any_from_visitable (*this); }
  void                          __aida_from_any__ (const Aida::Any &any) { return Aida::any_to_visitable (any, *this); }
  operator                      Aida::AnyDict     () const { return const_cast<SrvT_RecordWithAuxdata*> (this)->__aida_to_any__().get<Aida::AnyDict>(); }
  bool                          operator==  (const SrvT_RecordWithAuxdata &other) const;
  bool                          operator!=  (const SrvT_RecordWithAuxdata &other) const { return !operator== (other); }
  template<class Visitor> void  __accept__  (Visitor &_visitor_)
  {
    _visitor_ (aux_bool, "aux_bool");
    _visitor_ (aux32, "aux32");
    _visitor_ (aux64, "aux64");
    _visitor_ (auxf64, "auxf64");
    _visitor_ (aux_str, "aux_str");
  }
};
void operator<<= (Aida::ProtoMsg&, const SrvT_RecordWithAuxdata&);
void operator>>= (Aida::ProtoReader&, SrvT_RecordWithAuxdata&);
} // Auxdata

namespace InterfaceTests {

class I_UIWidgetAreaIface;
typedef std::shared_ptr<I_UIWidgetAreaIface> I_UIWidgetAreaIfaceP;
typedef std::weak_ptr  <I_UIWidgetAreaIface> I_UIWidgetAreaIfaceW;

class I_UIWidgetAreaIface : public virtual Aida::ImplicitBase
{
protected:
  explicit                              I_UIWidgetAreaIface ();
  virtual  /*dtor*/                    ~I_UIWidgetAreaIface () override = 0;
public:
  virtual Aida::TypeHashList            __aida_typelist__  () const override;
  virtual std::string                   __typename__       () const override	{ return "InterfaceTests::UIWidgetArea"; }
  virtual const Aida::StringVector&     __aida_aux_data__  () const override;
  virtual std::vector<std::string>      __aida_dir__       () const override;
  virtual Aida::Any                     __aida_get__       (const std::string &name) const override;
  virtual bool                          __aida_set__       (const std::string &name, const Aida::Any &any) override;
  virtual bool                          dummy    () const = 0;
  virtual void                          dummy    (bool) = 0;
  virtual std::string                   on_click () const = 0;
  virtual void                          on_click (const std::string&) = 0;
  virtual double                        simple_method       () = 0;
  virtual double                        single_arg          (int n) = 0;
  virtual double                        single_arg2         (int n = 5) = 0;
  virtual double                        two_args            (int n,
                                                             double r) = 0;
  virtual double                        two_args2           (int n = 6,
                                                             double r = 7.7) = 0;
  virtual double                        multi_args          (bool b,
                                                             int64_t n,
                                                             double r,
                                                             int i,
                                                             const std::string &s = "String ding",
                                                             double y = 5) = 0;
  virtual double                        self_method         (I_UIWidgetAreaIface &ba1,
                                                             I_UIWidgetAreaIface &ba2) = 0;
  virtual void                          void_method         () = 0;
  virtual std::string                   on_click2out        () = 0;
  virtual void                          on_click2in         (const std::string &command) = 0;
  template<class Visitor> void  __accept_accessor__ (Visitor &__visitor_)
  {
    __visitor_ (*this, "dummy", &I_UIWidgetAreaIface::dummy, &I_UIWidgetAreaIface::dummy);
    __visitor_ (*this, "on_click", &I_UIWidgetAreaIface::on_click, &I_UIWidgetAreaIface::on_click);
  }
};
void operator<<= (Aida::ProtoMsg&, const I_UIWidgetAreaIfaceP&);
void operator>>= (Aida::ProtoReader&, I_UIWidgetAreaIface*&);
void operator>>= (Aida::ProtoReader&, I_UIWidgetAreaIfaceP&);

class I_ParentIface;
typedef std::shared_ptr<I_ParentIface> I_ParentIfaceP;
typedef std::weak_ptr  <I_ParentIface> I_ParentIfaceW;

class I_ParentIface : public virtual Aida::ImplicitBase
{
protected:
  explicit                              I_ParentIface ();
  virtual  /*dtor*/                    ~I_ParentIface () override = 0;
public:
  virtual Aida::TypeHashList            __aida_typelist__  () const override;
  virtual std::string                   __typename__       () const override	{ return "InterfaceTests::Parent"; }
  virtual const Aida::StringVector&     __aida_aux_data__  () const override;
  virtual std::vector<std::string>      __aida_dir__       () const override;
  virtual Aida::Any                     __aida_get__       (const std::string &name) const override;
  virtual bool                          __aida_set__       (const std::string &name, const Aida::Any &any) override;
  template<class Visitor> void  __accept_accessor__ (Visitor &__visitor_)
  {}
};
void operator<<= (Aida::ProtoMsg&, const I_ParentIfaceP&);
void operator>>= (Aida::ProtoReader&, I_ParentIface*&);
void operator>>= (Aida::ProtoReader&, I_ParentIfaceP&);

class I_ChildIface;
typedef std::shared_ptr<I_ChildIface> I_ChildIfaceP;
typedef std::weak_ptr  <I_ChildIface> I_ChildIfaceW;

class I_ChildIface : public virtual I_ParentIface
{
protected:
  explicit                              I_ChildIface ();
  virtual  /*dtor*/                    ~I_ChildIface () override = 0;
public:
  virtual Aida::TypeHashList            __aida_typelist__  () const override;
  virtual std::string                   __typename__       () const override	{ return "InterfaceTests::Child"; }
  virtual const Aida::StringVector&     __aida_aux_data__  () const override;
  virtual std::vector<std::string>      __aida_dir__       () const override;
  virtual Aida::Any                     __aida_get__       (const std::string &name) const override;
  virtual bool                          __aida_set__       (const std::string &name, const Aida::Any &any) override;
  template<class Visitor> void  __accept_accessor__ (Visitor &__visitor_)
  {
    this->I_ParentIface::__accept_accessor__ (__visitor_);
  }
};
void operator<<= (Aida::ProtoMsg&, const I_ChildIfaceP&);
void operator>>= (Aida::ProtoReader&, I_ChildIface*&);
void operator>>= (Aida::ProtoReader&, I_ChildIfaceP&);

class I_DescendantIface;
typedef std::shared_ptr<I_DescendantIface> I_DescendantIfaceP;
typedef std::weak_ptr  <I_DescendantIface> I_DescendantIfaceW;

class I_DescendantIface : public virtual I_ChildIface
{
protected:
  explicit                              I_DescendantIface ();
  virtual  /*dtor*/                    ~I_DescendantIface () override = 0;
public:
  virtual Aida::TypeHashList            __aida_typelist__  () const override;
  virtual std::string                   __typename__       () const override	{ return "InterfaceTests::Descendant"; }
  virtual const Aida::StringVector&     __aida_aux_data__  () const override;
  virtual std::vector<std::string>      __aida_dir__       () const override;
  virtual Aida::Any                     __aida_get__       (const std::string &name) const override;
  virtual bool                          __aida_set__       (const std::string &name, const Aida::Any &any) override;
  template<class Visitor> void  __accept_accessor__ (Visitor &__visitor_)
  {
    this->I_ChildIface::__accept_accessor__ (__visitor_);
  }
};
void operator<<= (Aida::ProtoMsg&, const I_DescendantIfaceP&);
void operator>>= (Aida::ProtoReader&, I_DescendantIface*&);
void operator>>= (Aida::ProtoReader&, I_DescendantIfaceP&);

class I_GrandChildIface;
typedef std::shared_ptr<I_GrandChildIface> I_GrandChildIfaceP;
typedef std::weak_ptr  <I_GrandChildIface> I_GrandChildIfaceW;

class I_GrandChildIface : public virtual I_DescendantIface
{
protected:
  explicit                              I_GrandChildIface ();
  virtual  /*dtor*/                    ~I_GrandChildIface () override = 0;
public:
  virtual Aida::TypeHashList            __aida_typelist__  () const override;
  virtual std::string                   __typename__       () const override	{ return "InterfaceTests::GrandChild"; }
  virtual const Aida::StringVector&     __aida_aux_data__  () const override;
  virtual std::vector<std::string>      __aida_dir__       () const override;
  virtual Aida::Any                     __aida_get__       (const std::string &name) const override;
  virtual bool                          __aida_set__       (const std::string &name, const Aida::Any &any) override;
  template<class Visitor> void  __accept_accessor__ (Visitor &__visitor_)
  {
    this->I_DescendantIface::__accept_accessor__ (__visitor_);
  }
};
void operator<<= (Aida::ProtoMsg&, const I_GrandChildIfaceP&);
void operator>>= (Aida::ProtoReader&, I_GrandChildIface*&);
void operator>>= (Aida::ProtoReader&, I_GrandChildIfaceP&);

class SrvT_QuickRecord
{
public:
  /// @cond GeneratedFields
  int                           int1;
  int                           int2;
  /// @endcond
  inline                        SrvT_QuickRecord () { int1 = 0; int2 = 0; }
  inline                        SrvT_QuickRecord (const Aida::AnyDict &ad) : SrvT_QuickRecord() { __aida_from_any__ (Aida::Any (ad)); }
  std::string                   __typename__      () const	{ return "InterfaceTests::QuickRecord"; }
  const Aida::StringVector&     __aida_aux_data__ () const;
  Aida::Any                     __aida_to_any__   () { return Aida::any_from_visitable (*this); }
  void                          __aida_from_any__ (const Aida::Any &any) { return Aida::any_to_visitable (any, *this); }
  operator                      Aida::AnyDict     () const { return const_cast<SrvT_QuickRecord*> (this)->__aida_to_any__().get<Aida::AnyDict>(); }
  bool                          operator==  (const SrvT_QuickRecord &other) const;
  bool                          operator!=  (const SrvT_QuickRecord &other) const { return !operator== (other); }
  template<class Visitor> void  __accept__  (Visitor &_visitor_)
  {
    _visitor_ (int1, "int1");
    _visitor_ (int2, "int2");
  }
};
void operator<<= (Aida::ProtoMsg&, const SrvT_QuickRecord&);
void operator>>= (Aida::ProtoReader&, SrvT_QuickRecord&);

class SrvT_QuickSequence : public std::vector<double>
{
public:
  typedef std::vector<double> Sequence;
  reference append_back() ///< Append data at the end, returns write reference to data.
  { resize (size() + 1); return back(); }
  explicit                      SrvT_QuickSequence (std::initializer_list<value_type> il) : Sequence (il) {};
  inline                        SrvT_QuickSequence () = default;
  inline                        SrvT_QuickSequence (const Aida::AnyList &al) : SrvT_QuickSequence() { __aida_from_any__ (Aida::Any (al)); }
  std::string                   __typename__      () const	{ return "InterfaceTests::QuickSequence"; }
  const Aida::StringVector&     __aida_aux_data__ () const;
  Aida::Any                     __aida_to_any__   () { return Aida::any_from_sequence (*this); }
  void                          __aida_from_any__ (const Aida::Any &any) { return Aida::any_to_sequence (any, *this); }
  operator                      Aida::AnyList     () const { return const_cast<SrvT_QuickSequence*> (this)->__aida_to_any__().get<Aida::AnyList>(); }
};
void operator<<= (Aida::ProtoMsg&, const SrvT_QuickSequence&);
void operator>>= (Aida::ProtoReader&, SrvT_QuickSequence&);

class I_QuickIfaceIface;
typedef std::shared_ptr<I_QuickIfaceIface> I_QuickIfaceIfaceP;
typedef std::weak_ptr  <I_QuickIfaceIface> I_QuickIfaceIfaceW;

class I_QuickIfaceIface : public virtual Aida::ImplicitBase
{
protected:
  explicit                              I_QuickIfaceIface ();
  virtual  /*dtor*/                    ~I_QuickIfaceIface () override = 0;
public:
  virtual Aida::TypeHashList            __aida_typelist__  () const override;
  virtual std::string                   __typename__       () const override	{ return "InterfaceTests::QuickIface"; }
  virtual const Aida::StringVector&     __aida_aux_data__  () const override;
  virtual std::vector<std::string>      __aida_dir__       () const override;
  virtual Aida::Any                     __aida_get__       (const std::string &name) const override;
  virtual bool                          __aida_set__       (const std::string &name, const Aida::Any &any) override;
  virtual void                          simple_function   (int i = 9) = 0;
  template<class Visitor> void  __accept_accessor__ (Visitor &__visitor_)
  {}
};
void operator<<= (Aida::ProtoMsg&, const I_QuickIfaceIfaceP&);
void operator>>= (Aida::ProtoReader&, I_QuickIfaceIface*&);
void operator>>= (Aida::ProtoReader&, I_QuickIfaceIfaceP&);

class I_MethodTestInterfaceIface;
typedef std::shared_ptr<I_MethodTestInterfaceIface> I_MethodTestInterfaceIfaceP;
typedef std::weak_ptr  <I_MethodTestInterfaceIface> I_MethodTestInterfaceIfaceW;

class I_MethodTestInterfaceIface : public virtual Aida::ImplicitBase
{
protected:
  explicit                              I_MethodTestInterfaceIface ();
  virtual  /*dtor*/                    ~I_MethodTestInterfaceIface () override = 0;
public:
  virtual Aida::TypeHashList            __aida_typelist__  () const override;
  virtual std::string                   __typename__       () const override	{ return "InterfaceTests::MethodTestInterface"; }
  virtual const Aida::StringVector&     __aida_aux_data__  () const override;
  virtual std::vector<std::string>      __aida_dir__       () const override;
  virtual Aida::Any                     __aida_get__       (const std::string &name) const override;
  virtual bool                          __aida_set__       (const std::string &name, const Aida::Any &any) override;
  virtual void                          method_with_void           () = 0;
  virtual bool                          method_with_bools          (bool input,
                                                                    bool optval = 0) = 0;
  virtual int                           method_with_ints32         (int input,
                                                                    int optval = -2) = 0;
  virtual int64_t                       method_with_ints64         (int64_t input,
                                                                    int64_t optval = 576460752303423488) = 0;
  virtual double                        method_with_floats         (double input,
                                                                    double optval = 309.9) = 0;
  virtual std::string                   method_with_string         (const std::string &input,
                                                                    const std::string &optval = "default") = 0;
  virtual QuickEnum                     method_with_enum           (QuickEnum input,
                                                                    QuickEnum optval = QuickEnum (0)) = 0;
  virtual SrvT_QuickRecord              method_with_record         (const SrvT_QuickRecord &input,
                                                                    const SrvT_QuickRecord &optval = SrvT_QuickRecord()) = 0;
  virtual SrvT_QuickSequence            method_with_sequence       (const SrvT_QuickSequence &input,
                                                                    const SrvT_QuickSequence &optval = SrvT_QuickSequence()) = 0;
  virtual I_GrandChildIfaceP            method_with_interface      (I_GrandChildIface &input,
                                                                    I_GrandChildIface &optval = *(I_GrandChildIface*) NULL) = 0;
  virtual Aida::Any                     method_with_anys           (const Aida::Any &input,
                                                                    const Aida::Any &optval) = 0;
  virtual I_QuickIfaceIfaceP            method_with_quickiface     (I_QuickIfaceIface &input,
                                                                    I_QuickIfaceIface &iface0 = *(I_QuickIfaceIface*) NULL) = 0;
  template<class Visitor> void  __accept_accessor__ (Visitor &__visitor_)
  {}
};
void operator<<= (Aida::ProtoMsg&, const I_MethodTestInterfaceIfaceP&);
void operator>>= (Aida::ProtoReader&, I_MethodTestInterfaceIface*&);
void operator>>= (Aida::ProtoReader&, I_MethodTestInterfaceIfaceP&);

class I_SignalTestInterfaceIface;
typedef std::shared_ptr<I_SignalTestInterfaceIface> I_SignalTestInterfaceIfaceP;
typedef std::weak_ptr  <I_SignalTestInterfaceIface> I_SignalTestInterfaceIfaceW;

class I_SignalTestInterfaceIface : public virtual Aida::ImplicitBase
{
protected:
  explicit                              I_SignalTestInterfaceIface ();
  virtual  /*dtor*/                    ~I_SignalTestInterfaceIface () override = 0;
public:
  virtual Aida::TypeHashList            __aida_typelist__  () const override;
  virtual std::string                   __typename__       () const override	{ return "InterfaceTests::SignalTestInterface"; }
  virtual const Aida::StringVector&     __aida_aux_data__  () const override;
  virtual std::vector<std::string>      __aida_dir__       () const override;
  virtual Aida::Any                     __aida_get__       (const std::string &name) const override;
  virtual bool                          __aida_set__       (const std::string &name, const Aida::Any &any) override;
  template<class Visitor> void  __accept_accessor__ (Visitor &__visitor_)
  {}
};
void operator<<= (Aida::ProtoMsg&, const I_SignalTestInterfaceIfaceP&);
void operator>>= (Aida::ProtoReader&, I_SignalTestInterfaceIface*&);
void operator>>= (Aida::ProtoReader&, I_SignalTestInterfaceIfaceP&);

class I_ChildInheritingSignalsIface;
typedef std::shared_ptr<I_ChildInheritingSignalsIface> I_ChildInheritingSignalsIfaceP;
typedef std::weak_ptr  <I_ChildInheritingSignalsIface> I_ChildInheritingSignalsIfaceW;

class I_ChildInheritingSignalsIface : public virtual I_SignalTestInterfaceIface
{
protected:
  explicit                              I_ChildInheritingSignalsIface ();
  virtual  /*dtor*/                    ~I_ChildInheritingSignalsIface () override = 0;
public:
  virtual Aida::TypeHashList            __aida_typelist__  () const override;
  virtual std::string                   __typename__       () const override	{ return "InterfaceTests::ChildInheritingSignals"; }
  virtual const Aida::StringVector&     __aida_aux_data__  () const override;
  virtual std::vector<std::string>      __aida_dir__       () const override;
  virtual Aida::Any                     __aida_get__       (const std::string &name) const override;
  virtual bool                          __aida_set__       (const std::string &name, const Aida::Any &any) override;
  template<class Visitor> void  __accept_accessor__ (Visitor &__visitor_)
  {
    this->I_SignalTestInterfaceIface::__accept_accessor__ (__visitor_);
  }
};
void operator<<= (Aida::ProtoMsg&, const I_ChildInheritingSignalsIfaceP&);
void operator>>= (Aida::ProtoReader&, I_ChildInheritingSignalsIface*&);
void operator>>= (Aida::ProtoReader&, I_ChildInheritingSignalsIfaceP&);

class I_AnotherChildIface;
typedef std::shared_ptr<I_AnotherChildIface> I_AnotherChildIfaceP;
typedef std::weak_ptr  <I_AnotherChildIface> I_AnotherChildIfaceW;

class I_AnotherChildIface : public virtual I_SignalTestInterfaceIface
{
protected:
  explicit                              I_AnotherChildIface ();
  virtual  /*dtor*/                    ~I_AnotherChildIface () override = 0;
public:
  virtual Aida::TypeHashList            __aida_typelist__  () const override;
  virtual std::string                   __typename__       () const override	{ return "InterfaceTests::AnotherChild"; }
  virtual const Aida::StringVector&     __aida_aux_data__  () const override;
  virtual std::vector<std::string>      __aida_dir__       () const override;
  virtual Aida::Any                     __aida_get__       (const std::string &name) const override;
  virtual bool                          __aida_set__       (const std::string &name, const Aida::Any &any) override;
  template<class Visitor> void  __accept_accessor__ (Visitor &__visitor_)
  {
    this->I_SignalTestInterfaceIface::__accept_accessor__ (__visitor_);
  }
};
void operator<<= (Aida::ProtoMsg&, const I_AnotherChildIfaceP&);
void operator>>= (Aida::ProtoReader&, I_AnotherChildIface*&);
void operator>>= (Aida::ProtoReader&, I_AnotherChildIfaceP&);

class I_PropertyTesterIface;
typedef std::shared_ptr<I_PropertyTesterIface> I_PropertyTesterIfaceP;
typedef std::weak_ptr  <I_PropertyTesterIface> I_PropertyTesterIfaceW;

class I_PropertyTesterIface : public virtual Aida::ImplicitBase
{
protected:
  explicit                              I_PropertyTesterIface ();
  virtual  /*dtor*/                    ~I_PropertyTesterIface () override = 0;
public:
  virtual Aida::TypeHashList            __aida_typelist__  () const override;
  virtual std::string                   __typename__       () const override	{ return "InterfaceTests::PropertyTester"; }
  virtual const Aida::StringVector&     __aida_aux_data__  () const override;
  virtual std::vector<std::string>      __aida_dir__       () const override;
  virtual Aida::Any                     __aida_get__       (const std::string &name) const override;
  virtual bool                          __aida_set__       (const std::string &name, const Aida::Any &any) override;
  virtual bool                          bool_prop      () const = 0;
  virtual void                          bool_prop      (bool) = 0;
  virtual int                           int32_prop     () const = 0;
  virtual void                          int32_prop     (int) = 0;
  virtual int64_t                       int64_prop     () const = 0;
  virtual void                          int64_prop     (int64_t) = 0;
  virtual double                        float64_prop   () const = 0;
  virtual void                          float64_prop   (double) = 0;
  virtual std::string                   string_prop    () const = 0;
  virtual void                          string_prop    (const std::string&) = 0;
  virtual QuickEnum                     enum_prop      () const = 0;
  virtual void                          enum_prop      (QuickEnum) = 0;
  virtual SrvT_QuickRecord              record_prop    () const = 0;
  virtual void                          record_prop    (const SrvT_QuickRecord&) = 0;
  virtual SrvT_QuickSequence            sequence_prop  () const = 0;
  virtual void                          sequence_prop  (const SrvT_QuickSequence&) = 0;
  virtual I_GrandChildIfaceP            interface_prop () const = 0;
  virtual void                          interface_prop (I_GrandChildIface*) = 0;
  virtual I_PropertyTesterIfaceP        self_prop      () const = 0;
  virtual void                          self_prop      (I_PropertyTesterIface*) = 0;
  virtual Aida::Any                     any_prop       () const = 0;
  virtual void                          any_prop       (const Aida::Any&) = 0;
  template<class Visitor> void  __accept_accessor__ (Visitor &__visitor_)
  {
    __visitor_ (*this, "bool_prop", &I_PropertyTesterIface::bool_prop, &I_PropertyTesterIface::bool_prop);
    __visitor_ (*this, "int32_prop", &I_PropertyTesterIface::int32_prop, &I_PropertyTesterIface::int32_prop);
    __visitor_ (*this, "int64_prop", &I_PropertyTesterIface::int64_prop, &I_PropertyTesterIface::int64_prop);
    __visitor_ (*this, "float64_prop", &I_PropertyTesterIface::float64_prop, &I_PropertyTesterIface::float64_prop);
    __visitor_ (*this, "string_prop", &I_PropertyTesterIface::string_prop, &I_PropertyTesterIface::string_prop);
    __visitor_ (*this, "enum_prop", &I_PropertyTesterIface::enum_prop, &I_PropertyTesterIface::enum_prop);
    __visitor_ (*this, "record_prop", &I_PropertyTesterIface::record_prop, &I_PropertyTesterIface::record_prop);
    __visitor_ (*this, "sequence_prop", &I_PropertyTesterIface::sequence_prop, &I_PropertyTesterIface::sequence_prop);
    __visitor_ (*this, "interface_prop", &I_PropertyTesterIface::interface_prop, &I_PropertyTesterIface::interface_prop);
    __visitor_ (*this, "self_prop", &I_PropertyTesterIface::self_prop, &I_PropertyTesterIface::self_prop);
    __visitor_ (*this, "any_prop", &I_PropertyTesterIface::any_prop, &I_PropertyTesterIface::any_prop);
  }
};
void operator<<= (Aida::ProtoMsg&, const I_PropertyTesterIfaceP&);
void operator>>= (Aida::ProtoReader&, I_PropertyTesterIface*&);
void operator>>= (Aida::ProtoReader&, I_PropertyTesterIfaceP&);
} // InterfaceTests

namespace RapicornAidaTest {

class I_UseIncludesIface;
typedef std::shared_ptr<I_UseIncludesIface> I_UseIncludesIfaceP;
typedef std::weak_ptr  <I_UseIncludesIface> I_UseIncludesIfaceW;

class I_UseIncludesIface : public virtual IncludeCheck::I_SomeInterfaceIface
{
protected:
  explicit                              I_UseIncludesIface ();
  virtual  /*dtor*/                    ~I_UseIncludesIface () override = 0;
public:
  virtual Aida::TypeHashList            __aida_typelist__  () const override;
  virtual std::string                   __typename__       () const override	{ return "RapicornAidaTest::UseIncludes"; }
  virtual const Aida::StringVector&     __aida_aux_data__  () const override;
  virtual std::vector<std::string>      __aida_dir__       () const override;
  virtual Aida::Any                     __aida_get__       (const std::string &name) const override;
  virtual bool                          __aida_set__       (const std::string &name, const Aida::Any &any) override;
  template<class Visitor> void  __accept_accessor__ (Visitor &__visitor_)
  {
    this->IncludeCheck::I_SomeInterfaceIface::__accept_accessor__ (__visitor_);
  }
};
void operator<<= (Aida::ProtoMsg&, const I_UseIncludesIfaceP&);
void operator>>= (Aida::ProtoReader&, I_UseIncludesIface*&);
void operator>>= (Aida::ProtoReader&, I_UseIncludesIfaceP&);

class I_ButtonAreaIface;
typedef std::shared_ptr<I_ButtonAreaIface> I_ButtonAreaIfaceP;
typedef std::weak_ptr  <I_ButtonAreaIface> I_ButtonAreaIfaceW;

class I_ButtonAreaIface : public virtual Aida::ImplicitBase
{
protected:
  explicit                              I_ButtonAreaIface ();
  virtual  /*dtor*/                    ~I_ButtonAreaIface () override = 0;
public:
  virtual Aida::TypeHashList            __aida_typelist__  () const override;
  virtual std::string                   __typename__       () const override	{ return "RapicornAidaTest::ButtonArea"; }
  virtual const Aida::StringVector&     __aida_aux_data__  () const override;
  virtual std::vector<std::string>      __aida_dir__       () const override;
  virtual Aida::Any                     __aida_get__       (const std::string &name) const override;
  virtual bool                          __aida_set__       (const std::string &name, const Aida::Any &any) override;
  virtual std::string                   on_click   () const = 0;
  virtual void                          on_click   (const std::string&) = 0;
  virtual std::string                   on_click2  () const = 0;
  virtual void                          on_click2  (const std::string&) = 0;
  virtual std::string                   on_click3  () const = 0;
  virtual void                          on_click3  (const std::string&) = 0;
  virtual ClickType                     click_type () const = 0;
  virtual void                          click_type (ClickType) = 0;
  template<class Visitor> void  __accept_accessor__ (Visitor &__visitor_)
  {
    __visitor_ (*this, "on_click", &I_ButtonAreaIface::on_click, &I_ButtonAreaIface::on_click);
    __visitor_ (*this, "on_click2", &I_ButtonAreaIface::on_click2, &I_ButtonAreaIface::on_click2);
    __visitor_ (*this, "on_click3", &I_ButtonAreaIface::on_click3, &I_ButtonAreaIface::on_click3);
    __visitor_ (*this, "click_type", &I_ButtonAreaIface::click_type, &I_ButtonAreaIface::click_type);
  }
};
void operator<<= (Aida::ProtoMsg&, const I_ButtonAreaIfaceP&);
void operator>>= (Aida::ProtoReader&, I_ButtonAreaIface*&);
void operator>>= (Aida::ProtoReader&, I_ButtonAreaIfaceP&);

class I_PureMethodsIface;
typedef std::shared_ptr<I_PureMethodsIface> I_PureMethodsIfaceP;
typedef std::weak_ptr  <I_PureMethodsIface> I_PureMethodsIfaceW;


class I_PureMethodsIface : public virtual Aida::ImplicitBase
{
protected:
  explicit                              I_PureMethodsIface ();
  virtual  /*dtor*/                    ~I_PureMethodsIface () override = 0;
public:
  virtual Aida::TypeHashList            __aida_typelist__  () const override;
  virtual std::string                   __typename__       () const override	{ return "RapicornAidaTest::PureMethods"; }
  virtual const Aida::StringVector&     __aida_aux_data__  () const override;
  virtual std::vector<std::string>      __aida_dir__       () const override;
  virtual Aida::Any                     __aida_get__       (const std::string &name) const override;
  virtual bool                          __aida_set__       (const std::string &name, const Aida::Any &any) override;
  virtual int                           pure_method        (double f) = 0;
  template<class Visitor> void  __accept_accessor__ (Visitor &__visitor_)
  {}
};
void operator<<= (Aida::ProtoMsg&, const I_PureMethodsIfaceP&);
void operator>>= (Aida::ProtoReader&, I_PureMethodsIface*&);
void operator>>= (Aida::ProtoReader&, I_PureMethodsIfaceP&);
} // RapicornAidaTest

namespace Other {

class I_NameTestsIface;
typedef std::shared_ptr<I_NameTestsIface> I_NameTestsIfaceP;
typedef std::weak_ptr  <I_NameTestsIface> I_NameTestsIfaceW;

class I_NameTestsIface : public virtual Aida::ImplicitBase
{
protected:
  explicit                              I_NameTestsIface ();
  virtual  /*dtor*/                    ~I_NameTestsIface () override = 0;
public:
  virtual Aida::TypeHashList            __aida_typelist__  () const override;
  virtual std::string                   __typename__       () const override	{ return "Other::NameTests"; }
  virtual const Aida::StringVector&     __aida_aux_data__  () const override;
  virtual std::vector<std::string>      __aida_dir__       () const override;
  virtual Aida::Any                     __aida_get__       (const std::string &name) const override;
  virtual bool                          __aida_set__       (const std::string &name, const Aida::Any &any) override;
  virtual void                          args_from_other_namespace (const InterfaceTests::SrvT_QuickRecord &qr,
                                                                   RapicornAidaTest::ClickType qe,
                                                                   const OtherNamespace::SrvT_SomeRecord &sr) = 0;
  template<class Visitor> void  __accept_accessor__ (Visitor &__visitor_)
  {}
};
void operator<<= (Aida::ProtoMsg&, const I_NameTestsIfaceP&);
void operator>>= (Aida::ProtoReader&, I_NameTestsIface*&);
void operator>>= (Aida::ProtoReader&, I_NameTestsIfaceP&);
} // Other

namespace BseTest {

class I_CompressorIface;
typedef std::shared_ptr<I_CompressorIface> I_CompressorIfaceP;
typedef std::weak_ptr  <I_CompressorIface> I_CompressorIfaceW;

class I_CompressorIface : public virtual Aida::ImplicitBase
{
protected:
  explicit                              I_CompressorIface ();
  virtual  /*dtor*/                    ~I_CompressorIface () override = 0;
public:
  virtual Aida::TypeHashList            __aida_typelist__  () const override;
  virtual std::string                   __typename__       () const override	{ return "BseTest::Compressor"; }
  virtual const Aida::StringVector&     __aida_aux_data__  () const override;
  virtual std::vector<std::string>      __aida_dir__       () const override;
  virtual Aida::Any                     __aida_get__       (const std::string &name) const override;
  virtual bool                          __aida_set__       (const std::string &name, const Aida::Any &any) override;
  virtual double                        threshold () const = 0;
  virtual void                          threshold (double) = 0;
  virtual double                        ratio     () const = 0;
  virtual void                          ratio     (double) = 0;
  template<class Visitor> void  __accept_accessor__ (Visitor &__visitor_)
  {
    __visitor_ (*this, "threshold", &I_CompressorIface::threshold, &I_CompressorIface::threshold);
    __visitor_ (*this, "ratio", &I_CompressorIface::ratio, &I_CompressorIface::ratio);
  }
};
void operator<<= (Aida::ProtoMsg&, const I_CompressorIfaceP&);
void operator>>= (Aida::ProtoReader&, I_CompressorIface*&);
void operator>>= (Aida::ProtoReader&, I_CompressorIfaceP&);

class SrvT_RecordForGroups
{
public:
  /// @cond GeneratedFields
  int                           i;
  double                        ratio;
  bool                          ordinary_bool;
  double                        threshold1;
  double                        threshold2;
  /// @endcond
  inline                        SrvT_RecordForGroups () { i = 0; ratio = 0; ordinary_bool = 0; threshold1 = 0; threshold2 = 0; }
  inline                        SrvT_RecordForGroups (const Aida::AnyDict &ad) : SrvT_RecordForGroups() { __aida_from_any__ (Aida::Any (ad)); }
  std::string                   __typename__      () const	{ return "BseTest::RecordForGroups"; }
  const Aida::StringVector&     __aida_aux_data__ () const;
  Aida::Any                     __aida_to_any__   () { return Aida::any_from_visitable (*this); }
  void                          __aida_from_any__ (const Aida::Any &any) { return Aida::any_to_visitable (any, *this); }
  operator                      Aida::AnyDict     () const { return const_cast<SrvT_RecordForGroups*> (this)->__aida_to_any__().get<Aida::AnyDict>(); }
  bool                          operator==  (const SrvT_RecordForGroups &other) const;
  bool                          operator!=  (const SrvT_RecordForGroups &other) const { return !operator== (other); }
  template<class Visitor> void  __accept__  (Visitor &_visitor_)
  {
    _visitor_ (i, "i");
    _visitor_ (ratio, "ratio");
    _visitor_ (ordinary_bool, "ordinary_bool");
    _visitor_ (threshold1, "threshold1");
    _visitor_ (threshold2, "threshold2");
  }
};
void operator<<= (Aida::ProtoMsg&, const SrvT_RecordForGroups&);
void operator>>= (Aida::ProtoReader&, SrvT_RecordForGroups&);

class I_SoundModuleIface;
typedef std::shared_ptr<I_SoundModuleIface> I_SoundModuleIfaceP;
typedef std::weak_ptr  <I_SoundModuleIface> I_SoundModuleIfaceW;

class I_SoundModuleIface : public virtual Aida::ImplicitBase
{
protected:
  explicit                              I_SoundModuleIface ();
  virtual  /*dtor*/                    ~I_SoundModuleIface () override = 0;
public:
  virtual Aida::TypeHashList            __aida_typelist__  () const override;
  virtual std::string                   __typename__       () const override	{ return "BseTest::SoundModule"; }
  virtual const Aida::StringVector&     __aida_aux_data__  () const override;
  virtual std::vector<std::string>      __aida_dir__       () const override;
  virtual Aida::Any                     __aida_get__       (const std::string &name) const override;
  virtual bool                          __aida_set__       (const std::string &name, const Aida::Any &any) override;
  template<class Visitor> void  __accept_accessor__ (Visitor &__visitor_)
  {}
};
void operator<<= (Aida::ProtoMsg&, const I_SoundModuleIfaceP&);
void operator>>= (Aida::ProtoReader&, I_SoundModuleIface*&);
void operator>>= (Aida::ProtoReader&, I_SoundModuleIfaceP&);
} // BseTest

#define aidacc_tests_t304_testpass_idl_INTERFACE_LIST \
	  aidacc_tests_t304_testpass_idl_INTERFACE_NAME (MandatoryNamespace::FirstInterface) \
	  aidacc_tests_t304_testpass_idl_INTERFACE_NAME (InterfaceTests::UIWidgetArea) \
	  aidacc_tests_t304_testpass_idl_INTERFACE_NAME (InterfaceTests::Parent) \
	  aidacc_tests_t304_testpass_idl_INTERFACE_NAME (InterfaceTests::Child) \
	  aidacc_tests_t304_testpass_idl_INTERFACE_NAME (InterfaceTests::Descendant) \
	  aidacc_tests_t304_testpass_idl_INTERFACE_NAME (InterfaceTests::GrandChild) \
	  aidacc_tests_t304_testpass_idl_INTERFACE_NAME (InterfaceTests::QuickIface) \
	  aidacc_tests_t304_testpass_idl_INTERFACE_NAME (InterfaceTests::MethodTestInterface) \
	  aidacc_tests_t304_testpass_idl_INTERFACE_NAME (InterfaceTests::SignalTestInterface) \
	  aidacc_tests_t304_testpass_idl_INTERFACE_NAME (InterfaceTests::ChildInheritingSignals) \
	  aidacc_tests_t304_testpass_idl_INTERFACE_NAME (InterfaceTests::AnotherChild) \
	  aidacc_tests_t304_testpass_idl_INTERFACE_NAME (InterfaceTests::PropertyTester) \
	  aidacc_tests_t304_testpass_idl_INTERFACE_NAME (RapicornAidaTest::UseIncludes) \
	  aidacc_tests_t304_testpass_idl_INTERFACE_NAME (RapicornAidaTest::ButtonArea) \
	  aidacc_tests_t304_testpass_idl_INTERFACE_NAME (RapicornAidaTest::PureMethods) \
	  aidacc_tests_t304_testpass_idl_INTERFACE_NAME (Other::NameTests) \
	  aidacc_tests_t304_testpass_idl_INTERFACE_NAME (BseTest::Compressor) \
	  aidacc_tests_t304_testpass_idl_INTERFACE_NAME (BseTest::SoundModule)
#endif /* __SRVT__aidacc_tests_t304_testpass_idl */
// --- Generated by AidaCxxStub ---
#include "aidacc/tests/t304-testpass_interfaces.hh"

#define AIDA_ENUM_DEFINE_ARITHMETIC_EQ(Enum)   \
  bool constexpr operator== (Enum v, int64_t n) { return int64_t (v) == n; } \
  bool constexpr operator== (int64_t n, Enum v) { return n == int64_t (v); } \
  bool constexpr operator!= (Enum v, int64_t n) { return int64_t (v) != n; } \
  bool constexpr operator!= (int64_t n, Enum v) { return n != int64_t (v); }
#define AIDA_FLAGS_DEFINE_ARITHMETIC_OPS(Enum)   \
  static constexpr int64_t operator>> (Enum v, int64_t n) { return int64_t (v) >> n; } \
  static constexpr int64_t operator<< (Enum v, int64_t n) { return int64_t (v) << n; } \
  static constexpr int64_t operator^  (Enum v, int64_t n) { return int64_t (v) ^ n; } \
  static constexpr int64_t operator^  (int64_t n, Enum v) { return n ^ int64_t (v); } \
  static constexpr Enum    operator^  (Enum v, Enum w)    { return Enum (int64_t (v) ^ w); } \
  static constexpr int64_t operator|  (Enum v, int64_t n) { return int64_t (v) | n; } \
  static constexpr int64_t operator|  (int64_t n, Enum v) { return n | int64_t (v); } \
  static constexpr Enum    operator|  (Enum v, Enum w)    { return Enum (int64_t (v) | w); } \
  static constexpr int64_t operator&  (Enum v, int64_t n) { return int64_t (v) & n; } \
  static constexpr int64_t operator&  (int64_t n, Enum v) { return n & int64_t (v); } \
  static constexpr Enum    operator&  (Enum v, Enum w)    { return Enum (int64_t (v) & w); } \
  static constexpr int64_t operator~  (Enum v)            { return ~int64_t (v); } \
  static constexpr int64_t operator+  (Enum v)            { return +int64_t (v); } \
  static constexpr int64_t operator-  (Enum v)            { return -int64_t (v); } \
  static constexpr int64_t operator+  (Enum v, int64_t n) { return int64_t (v) + n; } \
  static constexpr int64_t operator+  (int64_t n, Enum v) { return n + int64_t (v); } \
  static constexpr int64_t operator-  (Enum v, int64_t n) { return int64_t (v) - n; } \
  static constexpr int64_t operator-  (int64_t n, Enum v) { return n - int64_t (v); } \
  static constexpr int64_t operator*  (Enum v, int64_t n) { return int64_t (v) * n; } \
  static constexpr int64_t operator*  (int64_t n, Enum v) { return n * int64_t (v); } \
  static constexpr int64_t operator/  (Enum v, int64_t n) { return int64_t (v) / n; } \
  static constexpr int64_t operator/  (int64_t n, Enum v) { return n / int64_t (v); } \
  static constexpr int64_t operator%  (Enum v, int64_t n) { return int64_t (v) % n; } \
  static constexpr int64_t operator%  (int64_t n, Enum v) { return n % int64_t (v); } \
  RAPICORN_FIXCYTHON_ENUM (Enum)
#ifdef     CYTHON_COMPILING_IN_CPYTHON
// Use C++ ADL, so PyInt_FromLong as generated by Cython works on scoped enums.
#define RAPICORN_FIXCYTHON_ENUM(Enum) \
  extern inline PyObject* PyInt_FromLong (Enum __e_) { return ::PyInt_FromLong (long (__e_)); }
#else  // !CYTHON_COMPILING_IN_CPYTHON
#define RAPICORN_FIXCYTHON_ENUM(Enum)
#endif // !CYTHON_COMPILING_IN_CPYTHON
#ifdef     AIDA_ENABLE_ENUM_ARITHMETIC
#define AIDA_ENUM_DEFINE_ARITHMETIC_OPS        AIDA_FLAGS_DEFINE_ARITHMETIC_OPS
#else  // !AIDA_ENABLE_ENUM_ARITHMETIC
#define AIDA_ENUM_DEFINE_ARITHMETIC_OPS(Enum)  /* no arithmetic ops */
#endif // !AIDA_ENABLE_ENUM_ARITHMETIC

using IntrospectionRegistry = Aida::IntrospectionRegistry;

#ifndef __AIDA_CXXSTUB_SERVER_CC__
#define __AIDA_CXXSTUB_SERVER_CC__

#ifndef AIDA_CPP_PASTE
#define AIDA_CPP_CAT2(a,b)    a ## b
#define AIDA_CPP_PASTE(a,b)     AIDA_CPP_CAT2 (a, b)
#endif

namespace { // Anon

namespace __AIDA_Local__ {
using namespace Aida;

// types
typedef ServerConnection::EmitResultHandler EmitResultHandler;
typedef ServerConnection::MethodRegistry    MethodRegistry;
typedef ServerConnection::MethodEntry       MethodEntry;

static_assert (std::is_base_of<Aida::ImplicitBase, Aida::ImplicitBase>::value,
               "IDL interface base 'Aida::ImplicitBase' must derive 'Aida::ImplicitBase'");

// objects
static inline ProtoMsg*
new_call_result (ProtoReader &fbr, uint64 h, uint64 l, uint32 n = 1)
{
  return ProtoMsg::renew_into_result (fbr, Aida::MSGID_CALL_RESULT, h, l, n);
}

static inline ProtoMsg*
new_connect_result (ProtoReader &fbr, uint64 h, uint64 l, uint32 n = 1)
{
  return ProtoMsg::renew_into_result (fbr, Aida::MSGID_CONNECT_RESULT, h, l, n);
}

// slot
template<class SharedPtr, class R, class... Args> std::function<R (Args...)>
slot (SharedPtr sp, R (*fp) (const SharedPtr&, Args...))
{
  return [sp, fp] (Args... args) { return fp (sp, args...); };
}

} } // Anon::__AIDA_Local__

#endif // __AIDA_CXXSTUB_SERVER_CC__


// --- Implementations ---

namespace MandatoryNamespace {

I_FirstInterfaceIface::I_FirstInterfaceIface ()
{}
I_FirstInterfaceIface::~I_FirstInterfaceIface ()
{} // define empty dtor to emit vtable
void
operator<<= (Aida::ProtoMsg &__p_, const I_FirstInterfaceIfaceP &ptr)
{
  __p_ <<= ptr.get();
}
void
operator>>= (Aida::ProtoReader &__f_, I_FirstInterfaceIfaceP &obj)
{
  obj = __f_.pop_instance<I_FirstInterfaceIface>();
}
void
operator>>= (Aida::ProtoReader &__f_, I_FirstInterfaceIface* &obj)
{
  obj = __f_.pop_instance<I_FirstInterfaceIface>().get();
}
Aida::TypeHashList
I_FirstInterfaceIface::__aida_typelist__ () const
{
  Aida::TypeHashList thl;
  thl.push_back (Aida::TypeHash (0x22113f623903ac14ULL, 0x3fe8e50c1a9a78d2ULL)); // FirstInterface
  return thl;
}
static const IntrospectionRegistry __aida_aux_data_srvt__MandatoryNamespace_FirstInterface_ = {
  "MandatoryNamespace::FirstInterface\0"
  "INTERFACE\0"
  ""};
const Aida::StringVector&
I_FirstInterfaceIface::__aida_aux_data__() const
{
  static const Aida::StringVector __d_ =
    ::Aida::aux_vectors_combine (IntrospectionRegistry::lookup ("MandatoryNamespace::FirstInterface"));
  return __d_;
}
std::vector<std::string>
I_FirstInterfaceIface::__aida_dir__ () const
{
  std::vector<std::string> __d_;
  return __d_;
}
Aida::Any
I_FirstInterfaceIface::__aida_get__ (const std::string &__n_) const
{
  Aida::Any __a_;
  return __a_;
}
bool
I_FirstInterfaceIface::__aida_set__ (const std::string &__n_, const Aida::Any &__a_)
{
  return false;
}
static const IntrospectionRegistry __aida_aux_data_srvt__MandatoryNamespace_XFooRecord_ = {
  "MandatoryNamespace::XFooRecord\0"
  "RECORD\0"
  "single_bool.type=BOOL\0"
  "single_num.type=INT32\0"
  "num64.type=INT64\0"
  "single_float.type=FLOAT64\0"
  "single_string.type=STRING\0"
  "sibling1.type=INT32\0"
  "sibling2.type=INT32\0"
  "multi1.type=INT32\0"
  "multi2.type=INT32\0"
  "multi3.type=INT32\0"
  "multi4.type=INT32\0"
  "enum_field.type=ENUM\0"
  "enum_field.typename=MandatoryNamespace::ExtensiveEnum\0"
  "iface1.type=INTERFACE\0"
  "iface1.typename=MandatoryNamespace::FirstInterface\0"
  "iface2.type=INTERFACE\0"
  "iface2.typename=MandatoryNamespace::FirstInterface\0"
  "iface3.type=INTERFACE\0"
  "iface3.typename=MandatoryNamespace::FirstInterface\0"
  "any1.type=ANY\0"
  "any2.type=ANY\0"
  "any3.type=ANY\0"
};
const Aida::StringVector&
SrvT_XFooRecord::__aida_aux_data__() const
{
  static const Aida::StringVector sv = IntrospectionRegistry::lookup ("MandatoryNamespace::XFooRecord");
  return sv;
}
bool
SrvT_XFooRecord::operator== (const SrvT_XFooRecord &other) const
{
  if (this->single_bool != other.single_bool) return false;
  if (this->single_num != other.single_num) return false;
  if (this->num64 != other.num64) return false;
  if (this->single_float != other.single_float) return false;
  if (this->single_string != other.single_string) return false;
  if (this->sibling1 != other.sibling1) return false;
  if (this->sibling2 != other.sibling2) return false;
  if (this->multi1 != other.multi1) return false;
  if (this->multi2 != other.multi2) return false;
  if (this->multi3 != other.multi3) return false;
  if (this->multi4 != other.multi4) return false;
  if (this->enum_field != other.enum_field) return false;
  if (this->iface1 != other.iface1) return false;
  if (this->iface2 != other.iface2) return false;
  if (this->iface3 != other.iface3) return false;
  if (this->any1 != other.any1) return false;
  if (this->any2 != other.any2) return false;
  if (this->any3 != other.any3) return false;
  return true;
}
inline void __attribute__ ((used))
operator<<= (Aida::ProtoMsg &dst, const SrvT_XFooRecord &self)
{
  Aida::ProtoMsg &__p_ = dst.add_rec (18);
  __p_ <<= self.single_bool;
  __p_ <<= self.single_num;
  __p_ <<= self.num64;
  __p_ <<= self.single_float;
  __p_ <<= self.single_string;
  __p_ <<= self.sibling1;
  __p_ <<= self.sibling2;
  __p_ <<= self.multi1;
  __p_ <<= self.multi2;
  __p_ <<= self.multi3;
  __p_ <<= self.multi4;
  __p_ <<= self.enum_field;
  __p_ <<= self.iface1;
  __p_ <<= self.iface2;
  __p_ <<= self.iface3;
  __p_ <<= self.any1;
  __p_ <<= self.any2;
  __p_ <<= self.any3;
}
inline void __attribute__ ((used))
operator>>= (Aida::ProtoReader &src, SrvT_XFooRecord &self)
{
  Aida::ProtoReader fbr (src.pop_rec());
  if (fbr.remaining() < 18) return;
  fbr >>= self.single_bool;
  fbr >>= self.single_num;
  fbr >>= self.num64;
  fbr >>= self.single_float;
  fbr >>= self.single_string;
  fbr >>= self.sibling1;
  fbr >>= self.sibling2;
  fbr >>= self.multi1;
  fbr >>= self.multi2;
  fbr >>= self.multi3;
  fbr >>= self.multi4;
  fbr >>= self.enum_field;
  fbr >>= self.iface1;
  fbr >>= self.iface2;
  fbr >>= self.iface3;
  fbr >>= self.any1;
  fbr >>= self.any2;
  fbr >>= self.any3;
}
static const IntrospectionRegistry __aida_aux_data_srvt__MandatoryNamespace_XFooSequence_ = {
  "MandatoryNamespace::XFooSequence\0"
  "SEQUENCE\0"
  "single_bool.type=BOOL\0"
};
const Aida::StringVector&
SrvT_XFooSequence::__aida_aux_data__() const
{
  static const Aida::StringVector sv = IntrospectionRegistry::lookup ("MandatoryNamespace::XFooSequence");
  return sv;
}
inline void __attribute__ ((used))
operator<<= (Aida::ProtoMsg &dst, const SrvT_XFooSequence &self)
{
  const size_t len = self.size();
  Aida::ProtoMsg &__p_ = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    __p_ <<= self[k];
  }
}
inline void __attribute__ ((used))
operator>>= (Aida::ProtoReader &src, SrvT_XFooSequence &self)
{
  Aida::ProtoReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >>= self[k];
  }
}
static const IntrospectionRegistry __aida_aux_data_srvt__MandatoryNamespace_IntSequence_ = {
  "MandatoryNamespace::IntSequence\0"
  "SEQUENCE\0"
  "numx.type=INT32\0"
};
const Aida::StringVector&
SrvT_IntSequence::__aida_aux_data__() const
{
  static const Aida::StringVector sv = IntrospectionRegistry::lookup ("MandatoryNamespace::IntSequence");
  return sv;
}
inline void __attribute__ ((used))
operator<<= (Aida::ProtoMsg &dst, const SrvT_IntSequence &self)
{
  const size_t len = self.size();
  Aida::ProtoMsg &__p_ = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    __p_ <<= self[k];
  }
}
inline void __attribute__ ((used))
operator>>= (Aida::ProtoReader &src, SrvT_IntSequence &self)
{
  Aida::ProtoReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >>= self[k];
  }
}
static const IntrospectionRegistry __aida_aux_data_srvt__MandatoryNamespace_FloatSequence_ = {
  "MandatoryNamespace::FloatSequence\0"
  "SEQUENCE\0"
  "fractalvalue.type=FLOAT64\0"
};
const Aida::StringVector&
SrvT_FloatSequence::__aida_aux_data__() const
{
  static const Aida::StringVector sv = IntrospectionRegistry::lookup ("MandatoryNamespace::FloatSequence");
  return sv;
}
inline void __attribute__ ((used))
operator<<= (Aida::ProtoMsg &dst, const SrvT_FloatSequence &self)
{
  const size_t len = self.size();
  Aida::ProtoMsg &__p_ = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    __p_ <<= self[k];
  }
}
inline void __attribute__ ((used))
operator>>= (Aida::ProtoReader &src, SrvT_FloatSequence &self)
{
  Aida::ProtoReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >>= self[k];
  }
}
static const IntrospectionRegistry __aida_aux_data_srvt__MandatoryNamespace_StringSequence_ = {
  "MandatoryNamespace::StringSequence\0"
  "SEQUENCE\0"
  "blurb.type=STRING\0"
};
const Aida::StringVector&
SrvT_StringSequence::__aida_aux_data__() const
{
  static const Aida::StringVector sv = IntrospectionRegistry::lookup ("MandatoryNamespace::StringSequence");
  return sv;
}
inline void __attribute__ ((used))
operator<<= (Aida::ProtoMsg &dst, const SrvT_StringSequence &self)
{
  const size_t len = self.size();
  Aida::ProtoMsg &__p_ = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    __p_ <<= self[k];
  }
}
inline void __attribute__ ((used))
operator>>= (Aida::ProtoReader &src, SrvT_StringSequence &self)
{
  Aida::ProtoReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >>= self[k];
  }
}
static const IntrospectionRegistry __aida_aux_data_srvt__MandatoryNamespace_ExtensiveEnumSequence_ = {
  "MandatoryNamespace::ExtensiveEnumSequence\0"
  "SEQUENCE\0"
  "enum_elements.type=ENUM\0"
  "enum_elements.typename=MandatoryNamespace::ExtensiveEnum\0"
};
const Aida::StringVector&
SrvT_ExtensiveEnumSequence::__aida_aux_data__() const
{
  static const Aida::StringVector sv = IntrospectionRegistry::lookup ("MandatoryNamespace::ExtensiveEnumSequence");
  return sv;
}
inline void __attribute__ ((used))
operator<<= (Aida::ProtoMsg &dst, const SrvT_ExtensiveEnumSequence &self)
{
  const size_t len = self.size();
  Aida::ProtoMsg &__p_ = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    __p_ <<= self[k];
  }
}
inline void __attribute__ ((used))
operator>>= (Aida::ProtoReader &src, SrvT_ExtensiveEnumSequence &self)
{
  Aida::ProtoReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >>= self[k];
  }
}
static const IntrospectionRegistry __aida_aux_data_srvt__MandatoryNamespace_RecordSequence_ = {
  "MandatoryNamespace::RecordSequence\0"
  "SEQUENCE\0"
  "repeatedfield.type=RECORD\0"
  "repeatedfield.typename=MandatoryNamespace::XFooRecord\0"
};
const Aida::StringVector&
SrvT_RecordSequence::__aida_aux_data__() const
{
  static const Aida::StringVector sv = IntrospectionRegistry::lookup ("MandatoryNamespace::RecordSequence");
  return sv;
}
inline void __attribute__ ((used))
operator<<= (Aida::ProtoMsg &dst, const SrvT_RecordSequence &self)
{
  const size_t len = self.size();
  Aida::ProtoMsg &__p_ = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    __p_ <<= self[k];
  }
}
inline void __attribute__ ((used))
operator>>= (Aida::ProtoReader &src, SrvT_RecordSequence &self)
{
  Aida::ProtoReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >>= self[k];
  }
}
static const IntrospectionRegistry __aida_aux_data_srvt__MandatoryNamespace_SequenceSequence_ = {
  "MandatoryNamespace::SequenceSequence\0"
  "SEQUENCE\0"
  "moreints.type=SEQUENCE\0"
  "moreints.typename=MandatoryNamespace::IntSequence\0"
};
const Aida::StringVector&
SrvT_SequenceSequence::__aida_aux_data__() const
{
  static const Aida::StringVector sv = IntrospectionRegistry::lookup ("MandatoryNamespace::SequenceSequence");
  return sv;
}
inline void __attribute__ ((used))
operator<<= (Aida::ProtoMsg &dst, const SrvT_SequenceSequence &self)
{
  const size_t len = self.size();
  Aida::ProtoMsg &__p_ = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    __p_ <<= self[k];
  }
}
inline void __attribute__ ((used))
operator>>= (Aida::ProtoReader &src, SrvT_SequenceSequence &self)
{
  Aida::ProtoReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >>= self[k];
  }
}
static const IntrospectionRegistry __aida_aux_data_srvt__MandatoryNamespace_InterfaceSequence_ = {
  "MandatoryNamespace::InterfaceSequence\0"
  "SEQUENCE\0"
  "iface1.type=INTERFACE\0"
  "iface1.typename=MandatoryNamespace::FirstInterface\0"
};
const Aida::StringVector&
SrvT_InterfaceSequence::__aida_aux_data__() const
{
  static const Aida::StringVector sv = IntrospectionRegistry::lookup ("MandatoryNamespace::InterfaceSequence");
  return sv;
}
inline void __attribute__ ((used))
operator<<= (Aida::ProtoMsg &dst, const SrvT_InterfaceSequence &self)
{
  const size_t len = self.size();
  Aida::ProtoMsg &__p_ = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    __p_ <<= self[k];
  }
}
inline void __attribute__ ((used))
operator>>= (Aida::ProtoReader &src, SrvT_InterfaceSequence &self)
{
  Aida::ProtoReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >>= self[k];
  }
}
static const IntrospectionRegistry __aida_aux_data_srvt__MandatoryNamespace_AnySequence_ = {
  "MandatoryNamespace::AnySequence\0"
  "SEQUENCE\0"
  "any_value.type=ANY\0"
};
const Aida::StringVector&
SrvT_AnySequence::__aida_aux_data__() const
{
  static const Aida::StringVector sv = IntrospectionRegistry::lookup ("MandatoryNamespace::AnySequence");
  return sv;
}
inline void __attribute__ ((used))
operator<<= (Aida::ProtoMsg &dst, const SrvT_AnySequence &self)
{
  const size_t len = self.size();
  Aida::ProtoMsg &__p_ = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    __p_ <<= self[k];
  }
}
inline void __attribute__ ((used))
operator>>= (Aida::ProtoReader &src, SrvT_AnySequence &self)
{
  Aida::ProtoReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >>= self[k];
  }
}
static const IntrospectionRegistry __aida_aux_data_srvt__MandatoryNamespace_NestedTypesRec_ = {
  "MandatoryNamespace::NestedTypesRec\0"
  "RECORD\0"
  "rec.type=RECORD\0"
  "rec.typename=MandatoryNamespace::XFooRecord\0"
  "seq.type=SEQUENCE\0"
  "seq.typename=MandatoryNamespace::XFooSequence\0"
};
const Aida::StringVector&
SrvT_NestedTypesRec::__aida_aux_data__() const
{
  static const Aida::StringVector sv = IntrospectionRegistry::lookup ("MandatoryNamespace::NestedTypesRec");
  return sv;
}
bool
SrvT_NestedTypesRec::operator== (const SrvT_NestedTypesRec &other) const
{
  if (this->rec != other.rec) return false;
  if (this->seq != other.seq) return false;
  return true;
}
inline void __attribute__ ((used))
operator<<= (Aida::ProtoMsg &dst, const SrvT_NestedTypesRec &self)
{
  Aida::ProtoMsg &__p_ = dst.add_rec (2);
  __p_ <<= self.rec;
  __p_ <<= self.seq;
}
inline void __attribute__ ((used))
operator>>= (Aida::ProtoReader &src, SrvT_NestedTypesRec &self)
{
  Aida::ProtoReader fbr (src.pop_rec());
  if (fbr.remaining() < 2) return;
  fbr >>= self.rec;
  fbr >>= self.seq;
}
static const IntrospectionRegistry __aida_aux_data_srvt__MandatoryNamespace_NestedTypesSeq_ = {
  "MandatoryNamespace::NestedTypesSeq\0"
  "SEQUENCE\0"
  "ntr.type=RECORD\0"
  "ntr.typename=MandatoryNamespace::NestedTypesRec\0"
};
const Aida::StringVector&
SrvT_NestedTypesSeq::__aida_aux_data__() const
{
  static const Aida::StringVector sv = IntrospectionRegistry::lookup ("MandatoryNamespace::NestedTypesSeq");
  return sv;
}
inline void __attribute__ ((used))
operator<<= (Aida::ProtoMsg &dst, const SrvT_NestedTypesSeq &self)
{
  const size_t len = self.size();
  Aida::ProtoMsg &__p_ = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    __p_ <<= self[k];
  }
}
inline void __attribute__ ((used))
operator>>= (Aida::ProtoReader &src, SrvT_NestedTypesSeq &self)
{
  Aida::ProtoReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >>= self[k];
  }
}
static const IntrospectionRegistry __aida_aux_data_srvt__MandatoryNamespace_NewRecord_ = {
  "MandatoryNamespace::NewRecord\0"
  "RECORD\0"
  "i.type=INT32\0"
  "enum1.type=ENUM\0"
  "enum1.typename=MandatoryNamespace::Enum1\0"
  "xfs.type=SEQUENCE\0"
  "xfs.typename=MandatoryNamespace::XFooSequence\0"
  "ntr.type=RECORD\0"
  "ntr.typename=MandatoryNamespace::NestedTypesRec\0"
};
const Aida::StringVector&
SrvT_NewRecord::__aida_aux_data__() const
{
  static const Aida::StringVector sv = IntrospectionRegistry::lookup ("MandatoryNamespace::NewRecord");
  return sv;
}
bool
SrvT_NewRecord::operator== (const SrvT_NewRecord &other) const
{
  if (this->i != other.i) return false;
  if (this->enum1 != other.enum1) return false;
  if (this->xfs != other.xfs) return false;
  if (this->ntr != other.ntr) return false;
  return true;
}
inline void __attribute__ ((used))
operator<<= (Aida::ProtoMsg &dst, const SrvT_NewRecord &self)
{
  Aida::ProtoMsg &__p_ = dst.add_rec (4);
  __p_ <<= self.i;
  __p_ <<= self.enum1;
  __p_ <<= self.xfs;
  __p_ <<= self.ntr;
}
inline void __attribute__ ((used))
operator>>= (Aida::ProtoReader &src, SrvT_NewRecord &self)
{
  Aida::ProtoReader fbr (src.pop_rec());
  if (fbr.remaining() < 4) return;
  fbr >>= self.i;
  fbr >>= self.enum1;
  fbr >>= self.xfs;
  fbr >>= self.ntr;
}

namespace Inner {
static const IntrospectionRegistry __aida_aux_data_srvt__MandatoryNamespace_Inner_InnerRecord_ = {
  "MandatoryNamespace::Inner::InnerRecord\0"
  "RECORD\0"
  "x.type=INT32\0"
  "y.type=INT32\0"
  "rec.type=RECORD\0"
  "rec.typename=MandatoryNamespace::NewRecord\0"
};
const Aida::StringVector&
SrvT_InnerRecord::__aida_aux_data__() const
{
  static const Aida::StringVector sv = IntrospectionRegistry::lookup ("MandatoryNamespace::Inner::InnerRecord");
  return sv;
}
bool
SrvT_InnerRecord::operator== (const SrvT_InnerRecord &other) const
{
  if (this->x != other.x) return false;
  if (this->y != other.y) return false;
  if (this->rec != other.rec) return false;
  return true;
}
inline void __attribute__ ((used))
operator<<= (Aida::ProtoMsg &dst, const SrvT_InnerRecord &self)
{
  Aida::ProtoMsg &__p_ = dst.add_rec (3);
  __p_ <<= self.x;
  __p_ <<= self.y;
  __p_ <<= self.rec;
}
inline void __attribute__ ((used))
operator>>= (Aida::ProtoReader &src, SrvT_InnerRecord &self)
{
  Aida::ProtoReader fbr (src.pop_rec());
  if (fbr.remaining() < 3) return;
  fbr >>= self.x;
  fbr >>= self.y;
  fbr >>= self.rec;
}
} // Inner
static const IntrospectionRegistry __aida_aux_data_srvt__MandatoryNamespace_Refer2Inner_ = {
  "MandatoryNamespace::Refer2Inner\0"
  "RECORD\0"
  "r.type=RECORD\0"
  "r.typename=MandatoryNamespace::Inner::InnerRecord\0"
};
const Aida::StringVector&
SrvT_Refer2Inner::__aida_aux_data__() const
{
  static const Aida::StringVector sv = IntrospectionRegistry::lookup ("MandatoryNamespace::Refer2Inner");
  return sv;
}
bool
SrvT_Refer2Inner::operator== (const SrvT_Refer2Inner &other) const
{
  if (this->r != other.r) return false;
  return true;
}
inline void __attribute__ ((used))
operator<<= (Aida::ProtoMsg &dst, const SrvT_Refer2Inner &self)
{
  Aida::ProtoMsg &__p_ = dst.add_rec (1);
  __p_ <<= self.r;
}
inline void __attribute__ ((used))
operator>>= (Aida::ProtoReader &src, SrvT_Refer2Inner &self)
{
  Aida::ProtoReader fbr (src.pop_rec());
  if (fbr.remaining() < 1) return;
  fbr >>= self.r;
}
} // MandatoryNamespace

namespace OtherNamespace {
static const IntrospectionRegistry __aida_aux_data_srvt__OtherNamespace_SomeRecord_ = {
  "OtherNamespace::SomeRecord\0"
  "RECORD\0"
  "r1.type=RECORD\0"
  "r1.typename=MandatoryNamespace::NewRecord\0"
  "r2.type=RECORD\0"
  "r2.typename=MandatoryNamespace::NewRecord\0"
  "r3.type=RECORD\0"
  "r3.typename=MandatoryNamespace::Inner::InnerRecord\0"
  "r4.type=RECORD\0"
  "r4.typename=MandatoryNamespace::Inner::InnerRecord\0"
};
const Aida::StringVector&
SrvT_SomeRecord::__aida_aux_data__() const
{
  static const Aida::StringVector sv = IntrospectionRegistry::lookup ("OtherNamespace::SomeRecord");
  return sv;
}
bool
SrvT_SomeRecord::operator== (const SrvT_SomeRecord &other) const
{
  if (this->r1 != other.r1) return false;
  if (this->r2 != other.r2) return false;
  if (this->r3 != other.r3) return false;
  if (this->r4 != other.r4) return false;
  return true;
}
inline void __attribute__ ((used))
operator<<= (Aida::ProtoMsg &dst, const SrvT_SomeRecord &self)
{
  Aida::ProtoMsg &__p_ = dst.add_rec (4);
  __p_ <<= self.r1;
  __p_ <<= self.r2;
  __p_ <<= self.r3;
  __p_ <<= self.r4;
}
inline void __attribute__ ((used))
operator>>= (Aida::ProtoReader &src, SrvT_SomeRecord &self)
{
  Aida::ProtoReader fbr (src.pop_rec());
  if (fbr.remaining() < 4) return;
  fbr >>= self.r1;
  fbr >>= self.r2;
  fbr >>= self.r3;
  fbr >>= self.r4;
}
} // OtherNamespace

namespace Auxdata {
static const IntrospectionRegistry __aida_aux_data_srvt__Auxdata_RecordWithAuxdata_ = {
  "Auxdata::RecordWithAuxdata\0"
  "RECORD\0"
  "aux_bool.type=BOOL\0"
  "aux_bool.label=AuxBool\0"
  "aux_bool.blurb=A Boolean\0"
  "aux_bool.hints=rw\0"
  "aux_bool.default=0\0"
  "aux32.type=INT32\0"
  "aux32.label=Aux32\0"
  "aux32.blurb=The Bar number\0"
  "aux32.hints=rw\0"
  "aux32.default=10007.0\0"
  "aux64.type=INT64\0"
  "aux64.label=Aux64\0"
  "aux64.blurb=64bit auxillary number\0"
  "aux64.hints=rw\0"
  "aux64.default=1152921504606846976\0"
  "auxf64.type=FLOAT64\0"
  "auxf64.label=AuxF64\0"
  "auxf64.blurb=X coordinate\0"
  "auxf64.hints=ro\0"
  "auxf64.default=0.019\0"
  "aux_str.type=STRING\0"
  "aux_str.label=AuxStr\0"
  "aux_str.blurb=Specify text here\0"
  "aux_str.hints=rw\0"
  "aux_str.default=auxtest3\0"
};
const Aida::StringVector&
SrvT_RecordWithAuxdata::__aida_aux_data__() const
{
  static const Aida::StringVector sv = IntrospectionRegistry::lookup ("Auxdata::RecordWithAuxdata");
  return sv;
}
bool
SrvT_RecordWithAuxdata::operator== (const SrvT_RecordWithAuxdata &other) const
{
  if (this->aux_bool != other.aux_bool) return false;
  if (this->aux32 != other.aux32) return false;
  if (this->aux64 != other.aux64) return false;
  if (this->auxf64 != other.auxf64) return false;
  if (this->aux_str != other.aux_str) return false;
  return true;
}
inline void __attribute__ ((used))
operator<<= (Aida::ProtoMsg &dst, const SrvT_RecordWithAuxdata &self)
{
  Aida::ProtoMsg &__p_ = dst.add_rec (5);
  __p_ <<= self.aux_bool;
  __p_ <<= self.aux32;
  __p_ <<= self.aux64;
  __p_ <<= self.auxf64;
  __p_ <<= self.aux_str;
}
inline void __attribute__ ((used))
operator>>= (Aida::ProtoReader &src, SrvT_RecordWithAuxdata &self)
{
  Aida::ProtoReader fbr (src.pop_rec());
  if (fbr.remaining() < 5) return;
  fbr >>= self.aux_bool;
  fbr >>= self.aux32;
  fbr >>= self.aux64;
  fbr >>= self.auxf64;
  fbr >>= self.aux_str;
}
} // Auxdata

namespace InterfaceTests {

I_UIWidgetAreaIface::I_UIWidgetAreaIface ()
{}
I_UIWidgetAreaIface::~I_UIWidgetAreaIface ()
{} // define empty dtor to emit vtable
void
operator<<= (Aida::ProtoMsg &__p_, const I_UIWidgetAreaIfaceP &ptr)
{
  __p_ <<= ptr.get();
}
void
operator>>= (Aida::ProtoReader &__f_, I_UIWidgetAreaIfaceP &obj)
{
  obj = __f_.pop_instance<I_UIWidgetAreaIface>();
}
void
operator>>= (Aida::ProtoReader &__f_, I_UIWidgetAreaIface* &obj)
{
  obj = __f_.pop_instance<I_UIWidgetAreaIface>().get();
}
Aida::TypeHashList
I_UIWidgetAreaIface::__aida_typelist__ () const
{
  Aida::TypeHashList thl;
  thl.push_back (Aida::TypeHash (0x11db82aaba1ee248ULL, 0xd2359653ff87e972ULL)); // UIWidgetArea
  return thl;
}
static const IntrospectionRegistry __aida_aux_data_srvt__InterfaceTests_UIWidgetArea_ = {
  "InterfaceTests::UIWidgetArea\0"
  "INTERFACE\0"
  "dummy.type=BOOL\0"
  "on_click.type=STRING\0"
  "on_click.label=On CLick\0"
  "on_click.blurb=Command on button1 click\0"
  "on_click.hints=rw\0"
};
const Aida::StringVector&
I_UIWidgetAreaIface::__aida_aux_data__() const
{
  static const Aida::StringVector __d_ =
    ::Aida::aux_vectors_combine (IntrospectionRegistry::lookup ("InterfaceTests::UIWidgetArea"));
  return __d_;
}
std::vector<std::string>
I_UIWidgetAreaIface::__aida_dir__ () const
{
  std::vector<std::string> __d_;
  __d_.push_back ("dummy");
  __d_.push_back ("on_click");
  return __d_;
}
Aida::Any
I_UIWidgetAreaIface::__aida_get__ (const std::string &__n_) const
{
  Aida::Any __a_;
  if (__n_ == "dummy")           { __a_.set (dummy()); return __a_; }
  if (__n_ == "on_click")        { __a_.set (on_click()); return __a_; }
  return __a_;
}
bool
I_UIWidgetAreaIface::__aida_set__ (const std::string &__n_, const Aida::Any &__a_)
{
  if (__n_ == "dummy")           { dummy (__a_.get<bool>()); return true; }
  if (__n_ == "on_click")        { on_click (__a_.get<std::string>()); return true; }
  return false;
}

I_ParentIface::I_ParentIface ()
{}
I_ParentIface::~I_ParentIface ()
{} // define empty dtor to emit vtable
void
operator<<= (Aida::ProtoMsg &__p_, const I_ParentIfaceP &ptr)
{
  __p_ <<= ptr.get();
}
void
operator>>= (Aida::ProtoReader &__f_, I_ParentIfaceP &obj)
{
  obj = __f_.pop_instance<I_ParentIface>();
}
void
operator>>= (Aida::ProtoReader &__f_, I_ParentIface* &obj)
{
  obj = __f_.pop_instance<I_ParentIface>().get();
}
Aida::TypeHashList
I_ParentIface::__aida_typelist__ () const
{
  Aida::TypeHashList thl;
  thl.push_back (Aida::TypeHash (0xf3967d3ac61708d2ULL, 0x4043a82003ee6f1eULL)); // Parent
  return thl;
}
static const IntrospectionRegistry __aida_aux_data_srvt__InterfaceTests_Parent_ = {
  "InterfaceTests::Parent\0"
  "INTERFACE\0"
  ""};
const Aida::StringVector&
I_ParentIface::__aida_aux_data__() const
{
  static const Aida::StringVector __d_ =
    ::Aida::aux_vectors_combine (IntrospectionRegistry::lookup ("InterfaceTests::Parent"));
  return __d_;
}
std::vector<std::string>
I_ParentIface::__aida_dir__ () const
{
  std::vector<std::string> __d_;
  return __d_;
}
Aida::Any
I_ParentIface::__aida_get__ (const std::string &__n_) const
{
  Aida::Any __a_;
  return __a_;
}
bool
I_ParentIface::__aida_set__ (const std::string &__n_, const Aida::Any &__a_)
{
  return false;
}

I_ChildIface::I_ChildIface ()
{}
I_ChildIface::~I_ChildIface ()
{} // define empty dtor to emit vtable
void
operator<<= (Aida::ProtoMsg &__p_, const I_ChildIfaceP &ptr)
{
  __p_ <<= ptr.get();
}
void
operator>>= (Aida::ProtoReader &__f_, I_ChildIfaceP &obj)
{
  obj = __f_.pop_instance<I_ChildIface>();
}
void
operator>>= (Aida::ProtoReader &__f_, I_ChildIface* &obj)
{
  obj = __f_.pop_instance<I_ChildIface>().get();
}
Aida::TypeHashList
I_ChildIface::__aida_typelist__ () const
{
  Aida::TypeHashList thl;
  thl.push_back (Aida::TypeHash (0xacf30fad3093ffcdULL, 0x4d8c65c035fba090ULL)); // Child
  thl.push_back (Aida::TypeHash (0xf3967d3ac61708d2ULL, 0x4043a82003ee6f1eULL)); // Parent
  return thl;
}
static const IntrospectionRegistry __aida_aux_data_srvt__InterfaceTests_Child_ = {
  "InterfaceTests::Child\0"
  "INTERFACE\0"
  ""};
const Aida::StringVector&
I_ChildIface::__aida_aux_data__() const
{
  static const Aida::StringVector __d_ =
    ::Aida::aux_vectors_combine (IntrospectionRegistry::lookup ("InterfaceTests::Child"),
                                 this->I_ParentIface::__aida_aux_data__());
  return __d_;
}
std::vector<std::string>
I_ChildIface::__aida_dir__ () const
{
  std::vector<std::string> __d_;
  { const Aida::StringVector &__t_ = this->I_ParentIface::__aida_dir__();
    __d_.insert (__d_.end(), __t_.begin(), __t_.end()); }
  return __d_;
}
Aida::Any
I_ChildIface::__aida_get__ (const std::string &__n_) const
{
  Aida::Any __a_;
  __a_ = this->I_ParentIface::__aida_get__ (__n_); if (__a_.kind()) return __a_;
  return __a_;
}
bool
I_ChildIface::__aida_set__ (const std::string &__n_, const Aida::Any &__a_)
{
  if (this->I_ParentIface::__aida_set__ (__n_, __a_)) return true;
  return false;
}

I_DescendantIface::I_DescendantIface ()
{}
I_DescendantIface::~I_DescendantIface ()
{} // define empty dtor to emit vtable
void
operator<<= (Aida::ProtoMsg &__p_, const I_DescendantIfaceP &ptr)
{
  __p_ <<= ptr.get();
}
void
operator>>= (Aida::ProtoReader &__f_, I_DescendantIfaceP &obj)
{
  obj = __f_.pop_instance<I_DescendantIface>();
}
void
operator>>= (Aida::ProtoReader &__f_, I_DescendantIface* &obj)
{
  obj = __f_.pop_instance<I_DescendantIface>().get();
}
Aida::TypeHashList
I_DescendantIface::__aida_typelist__ () const
{
  Aida::TypeHashList thl;
  thl.push_back (Aida::TypeHash (0x846a6876889dd896ULL, 0xbe521465806f3d42ULL)); // Descendant
  thl.push_back (Aida::TypeHash (0xf3967d3ac61708d2ULL, 0x4043a82003ee6f1eULL)); // Parent
  thl.push_back (Aida::TypeHash (0xacf30fad3093ffcdULL, 0x4d8c65c035fba090ULL)); // Child
  return thl;
}
static const IntrospectionRegistry __aida_aux_data_srvt__InterfaceTests_Descendant_ = {
  "InterfaceTests::Descendant\0"
  "INTERFACE\0"
  ""};
const Aida::StringVector&
I_DescendantIface::__aida_aux_data__() const
{
  static const Aida::StringVector __d_ =
    ::Aida::aux_vectors_combine (IntrospectionRegistry::lookup ("InterfaceTests::Descendant"),
                                 this->I_ChildIface::__aida_aux_data__());
  return __d_;
}
std::vector<std::string>
I_DescendantIface::__aida_dir__ () const
{
  std::vector<std::string> __d_;
  { const Aida::StringVector &__t_ = this->I_ChildIface::__aida_dir__();
    __d_.insert (__d_.end(), __t_.begin(), __t_.end()); }
  return __d_;
}
Aida::Any
I_DescendantIface::__aida_get__ (const std::string &__n_) const
{
  Aida::Any __a_;
  __a_ = this->I_ChildIface::__aida_get__ (__n_); if (__a_.kind()) return __a_;
  return __a_;
}
bool
I_DescendantIface::__aida_set__ (const std::string &__n_, const Aida::Any &__a_)
{
  if (this->I_ChildIface::__aida_set__ (__n_, __a_)) return true;
  return false;
}

I_GrandChildIface::I_GrandChildIface ()
{}
I_GrandChildIface::~I_GrandChildIface ()
{} // define empty dtor to emit vtable
void
operator<<= (Aida::ProtoMsg &__p_, const I_GrandChildIfaceP &ptr)
{
  __p_ <<= ptr.get();
}
void
operator>>= (Aida::ProtoReader &__f_, I_GrandChildIfaceP &obj)
{
  obj = __f_.pop_instance<I_GrandChildIface>();
}
void
operator>>= (Aida::ProtoReader &__f_, I_GrandChildIface* &obj)
{
  obj = __f_.pop_instance<I_GrandChildIface>().get();
}
Aida::TypeHashList
I_GrandChildIface::__aida_typelist__ () const
{
  Aida::TypeHashList thl;
  thl.push_back (Aida::TypeHash (0xf6975e5e92250718ULL, 0x53730d44919c46f9ULL)); // GrandChild
  thl.push_back (Aida::TypeHash (0xf3967d3ac61708d2ULL, 0x4043a82003ee6f1eULL)); // Parent
  thl.push_back (Aida::TypeHash (0xacf30fad3093ffcdULL, 0x4d8c65c035fba090ULL)); // Child
  thl.push_back (Aida::TypeHash (0x846a6876889dd896ULL, 0xbe521465806f3d42ULL)); // Descendant
  return thl;
}
static const IntrospectionRegistry __aida_aux_data_srvt__InterfaceTests_GrandChild_ = {
  "InterfaceTests::GrandChild\0"
  "INTERFACE\0"
  ""};
const Aida::StringVector&
I_GrandChildIface::__aida_aux_data__() const
{
  static const Aida::StringVector __d_ =
    ::Aida::aux_vectors_combine (IntrospectionRegistry::lookup ("InterfaceTests::GrandChild"),
                                 this->I_DescendantIface::__aida_aux_data__());
  return __d_;
}
std::vector<std::string>
I_GrandChildIface::__aida_dir__ () const
{
  std::vector<std::string> __d_;
  { const Aida::StringVector &__t_ = this->I_DescendantIface::__aida_dir__();
    __d_.insert (__d_.end(), __t_.begin(), __t_.end()); }
  return __d_;
}
Aida::Any
I_GrandChildIface::__aida_get__ (const std::string &__n_) const
{
  Aida::Any __a_;
  __a_ = this->I_DescendantIface::__aida_get__ (__n_); if (__a_.kind()) return __a_;
  return __a_;
}
bool
I_GrandChildIface::__aida_set__ (const std::string &__n_, const Aida::Any &__a_)
{
  if (this->I_DescendantIface::__aida_set__ (__n_, __a_)) return true;
  return false;
}
static const IntrospectionRegistry __aida_aux_data_srvt__InterfaceTests_QuickRecord_ = {
  "InterfaceTests::QuickRecord\0"
  "RECORD\0"
  "int1.type=INT32\0"
  "int2.type=INT32\0"
};
const Aida::StringVector&
SrvT_QuickRecord::__aida_aux_data__() const
{
  static const Aida::StringVector sv = IntrospectionRegistry::lookup ("InterfaceTests::QuickRecord");
  return sv;
}
bool
SrvT_QuickRecord::operator== (const SrvT_QuickRecord &other) const
{
  if (this->int1 != other.int1) return false;
  if (this->int2 != other.int2) return false;
  return true;
}
inline void __attribute__ ((used))
operator<<= (Aida::ProtoMsg &dst, const SrvT_QuickRecord &self)
{
  Aida::ProtoMsg &__p_ = dst.add_rec (2);
  __p_ <<= self.int1;
  __p_ <<= self.int2;
}
inline void __attribute__ ((used))
operator>>= (Aida::ProtoReader &src, SrvT_QuickRecord &self)
{
  Aida::ProtoReader fbr (src.pop_rec());
  if (fbr.remaining() < 2) return;
  fbr >>= self.int1;
  fbr >>= self.int2;
}
static const IntrospectionRegistry __aida_aux_data_srvt__InterfaceTests_QuickSequence_ = {
  "InterfaceTests::QuickSequence\0"
  "SEQUENCE\0"
  "somefloat.type=FLOAT64\0"
};
const Aida::StringVector&
SrvT_QuickSequence::__aida_aux_data__() const
{
  static const Aida::StringVector sv = IntrospectionRegistry::lookup ("InterfaceTests::QuickSequence");
  return sv;
}
inline void __attribute__ ((used))
operator<<= (Aida::ProtoMsg &dst, const SrvT_QuickSequence &self)
{
  const size_t len = self.size();
  Aida::ProtoMsg &__p_ = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    __p_ <<= self[k];
  }
}
inline void __attribute__ ((used))
operator>>= (Aida::ProtoReader &src, SrvT_QuickSequence &self)
{
  Aida::ProtoReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >>= self[k];
  }
}

I_QuickIfaceIface::I_QuickIfaceIface ()
{}
I_QuickIfaceIface::~I_QuickIfaceIface ()
{} // define empty dtor to emit vtable
void
operator<<= (Aida::ProtoMsg &__p_, const I_QuickIfaceIfaceP &ptr)
{
  __p_ <<= ptr.get();
}
void
operator>>= (Aida::ProtoReader &__f_, I_QuickIfaceIfaceP &obj)
{
  obj = __f_.pop_instance<I_QuickIfaceIface>();
}
void
operator>>= (Aida::ProtoReader &__f_, I_QuickIfaceIface* &obj)
{
  obj = __f_.pop_instance<I_QuickIfaceIface>().get();
}
Aida::TypeHashList
I_QuickIfaceIface::__aida_typelist__ () const
{
  Aida::TypeHashList thl;
  thl.push_back (Aida::TypeHash (0x4524ee119d4e454cULL, 0xbeb61f7c3cc04f7dULL)); // QuickIface
  return thl;
}
static const IntrospectionRegistry __aida_aux_data_srvt__InterfaceTests_QuickIface_ = {
  "InterfaceTests::QuickIface\0"
  "INTERFACE\0"
  ""};
const Aida::StringVector&
I_QuickIfaceIface::__aida_aux_data__() const
{
  static const Aida::StringVector __d_ =
    ::Aida::aux_vectors_combine (IntrospectionRegistry::lookup ("InterfaceTests::QuickIface"));
  return __d_;
}
std::vector<std::string>
I_QuickIfaceIface::__aida_dir__ () const
{
  std::vector<std::string> __d_;
  return __d_;
}
Aida::Any
I_QuickIfaceIface::__aida_get__ (const std::string &__n_) const
{
  Aida::Any __a_;
  return __a_;
}
bool
I_QuickIfaceIface::__aida_set__ (const std::string &__n_, const Aida::Any &__a_)
{
  return false;
}

I_MethodTestInterfaceIface::I_MethodTestInterfaceIface ()
{}
I_MethodTestInterfaceIface::~I_MethodTestInterfaceIface ()
{} // define empty dtor to emit vtable
void
operator<<= (Aida::ProtoMsg &__p_, const I_MethodTestInterfaceIfaceP &ptr)
{
  __p_ <<= ptr.get();
}
void
operator>>= (Aida::ProtoReader &__f_, I_MethodTestInterfaceIfaceP &obj)
{
  obj = __f_.pop_instance<I_MethodTestInterfaceIface>();
}
void
operator>>= (Aida::ProtoReader &__f_, I_MethodTestInterfaceIface* &obj)
{
  obj = __f_.pop_instance<I_MethodTestInterfaceIface>().get();
}
Aida::TypeHashList
I_MethodTestInterfaceIface::__aida_typelist__ () const
{
  Aida::TypeHashList thl;
  thl.push_back (Aida::TypeHash (0x6bf684458ac5f01aULL, 0xf64c02611b807180ULL)); // MethodTestInterface
  return thl;
}
static const IntrospectionRegistry __aida_aux_data_srvt__InterfaceTests_MethodTestInterface_ = {
  "InterfaceTests::MethodTestInterface\0"
  "INTERFACE\0"
  ""};
const Aida::StringVector&
I_MethodTestInterfaceIface::__aida_aux_data__() const
{
  static const Aida::StringVector __d_ =
    ::Aida::aux_vectors_combine (IntrospectionRegistry::lookup ("InterfaceTests::MethodTestInterface"));
  return __d_;
}
std::vector<std::string>
I_MethodTestInterfaceIface::__aida_dir__ () const
{
  std::vector<std::string> __d_;
  return __d_;
}
Aida::Any
I_MethodTestInterfaceIface::__aida_get__ (const std::string &__n_) const
{
  Aida::Any __a_;
  return __a_;
}
bool
I_MethodTestInterfaceIface::__aida_set__ (const std::string &__n_, const Aida::Any &__a_)
{
  return false;
}

I_SignalTestInterfaceIface::I_SignalTestInterfaceIface ()
{}
I_SignalTestInterfaceIface::~I_SignalTestInterfaceIface ()
{} // define empty dtor to emit vtable
void
operator<<= (Aida::ProtoMsg &__p_, const I_SignalTestInterfaceIfaceP &ptr)
{
  __p_ <<= ptr.get();
}
void
operator>>= (Aida::ProtoReader &__f_, I_SignalTestInterfaceIfaceP &obj)
{
  obj = __f_.pop_instance<I_SignalTestInterfaceIface>();
}
void
operator>>= (Aida::ProtoReader &__f_, I_SignalTestInterfaceIface* &obj)
{
  obj = __f_.pop_instance<I_SignalTestInterfaceIface>().get();
}
Aida::TypeHashList
I_SignalTestInterfaceIface::__aida_typelist__ () const
{
  Aida::TypeHashList thl;
  thl.push_back (Aida::TypeHash (0x2873064ee22c0249ULL, 0xd8fae6f300b8e408ULL)); // SignalTestInterface
  return thl;
}
static const IntrospectionRegistry __aida_aux_data_srvt__InterfaceTests_SignalTestInterface_ = {
  "InterfaceTests::SignalTestInterface\0"
  "INTERFACE\0"
  ""};
const Aida::StringVector&
I_SignalTestInterfaceIface::__aida_aux_data__() const
{
  static const Aida::StringVector __d_ =
    ::Aida::aux_vectors_combine (IntrospectionRegistry::lookup ("InterfaceTests::SignalTestInterface"));
  return __d_;
}
std::vector<std::string>
I_SignalTestInterfaceIface::__aida_dir__ () const
{
  std::vector<std::string> __d_;
  return __d_;
}
Aida::Any
I_SignalTestInterfaceIface::__aida_get__ (const std::string &__n_) const
{
  Aida::Any __a_;
  return __a_;
}
bool
I_SignalTestInterfaceIface::__aida_set__ (const std::string &__n_, const Aida::Any &__a_)
{
  return false;
}

I_ChildInheritingSignalsIface::I_ChildInheritingSignalsIface ()
{}
I_ChildInheritingSignalsIface::~I_ChildInheritingSignalsIface ()
{} // define empty dtor to emit vtable
void
operator<<= (Aida::ProtoMsg &__p_, const I_ChildInheritingSignalsIfaceP &ptr)
{
  __p_ <<= ptr.get();
}
void
operator>>= (Aida::ProtoReader &__f_, I_ChildInheritingSignalsIfaceP &obj)
{
  obj = __f_.pop_instance<I_ChildInheritingSignalsIface>();
}
void
operator>>= (Aida::ProtoReader &__f_, I_ChildInheritingSignalsIface* &obj)
{
  obj = __f_.pop_instance<I_ChildInheritingSignalsIface>().get();
}
Aida::TypeHashList
I_ChildInheritingSignalsIface::__aida_typelist__ () const
{
  Aida::TypeHashList thl;
  thl.push_back (Aida::TypeHash (0xf20ff30241b5b694ULL, 0x9f544b2626e183f0ULL)); // ChildInheritingSignals
  thl.push_back (Aida::TypeHash (0x2873064ee22c0249ULL, 0xd8fae6f300b8e408ULL)); // SignalTestInterface
  return thl;
}
static const IntrospectionRegistry __aida_aux_data_srvt__InterfaceTests_ChildInheritingSignals_ = {
  "InterfaceTests::ChildInheritingSignals\0"
  "INTERFACE\0"
  ""};
const Aida::StringVector&
I_ChildInheritingSignalsIface::__aida_aux_data__() const
{
  static const Aida::StringVector __d_ =
    ::Aida::aux_vectors_combine (IntrospectionRegistry::lookup ("InterfaceTests::ChildInheritingSignals"),
                                 this->I_SignalTestInterfaceIface::__aida_aux_data__());
  return __d_;
}
std::vector<std::string>
I_ChildInheritingSignalsIface::__aida_dir__ () const
{
  std::vector<std::string> __d_;
  { const Aida::StringVector &__t_ = this->I_SignalTestInterfaceIface::__aida_dir__();
    __d_.insert (__d_.end(), __t_.begin(), __t_.end()); }
  return __d_;
}
Aida::Any
I_ChildInheritingSignalsIface::__aida_get__ (const std::string &__n_) const
{
  Aida::Any __a_;
  __a_ = this->I_SignalTestInterfaceIface::__aida_get__ (__n_); if (__a_.kind()) return __a_;
  return __a_;
}
bool
I_ChildInheritingSignalsIface::__aida_set__ (const std::string &__n_, const Aida::Any &__a_)
{
  if (this->I_SignalTestInterfaceIface::__aida_set__ (__n_, __a_)) return true;
  return false;
}

I_AnotherChildIface::I_AnotherChildIface ()
{}
I_AnotherChildIface::~I_AnotherChildIface ()
{} // define empty dtor to emit vtable
void
operator<<= (Aida::ProtoMsg &__p_, const I_AnotherChildIfaceP &ptr)
{
  __p_ <<= ptr.get();
}
void
operator>>= (Aida::ProtoReader &__f_, I_AnotherChildIfaceP &obj)
{
  obj = __f_.pop_instance<I_AnotherChildIface>();
}
void
operator>>= (Aida::ProtoReader &__f_, I_AnotherChildIface* &obj)
{
  obj = __f_.pop_instance<I_AnotherChildIface>().get();
}
Aida::TypeHashList
I_AnotherChildIface::__aida_typelist__ () const
{
  Aida::TypeHashList thl;
  thl.push_back (Aida::TypeHash (0x9a33af1b27f7e36dULL, 0xdf625f7bd18934faULL)); // AnotherChild
  thl.push_back (Aida::TypeHash (0x2873064ee22c0249ULL, 0xd8fae6f300b8e408ULL)); // SignalTestInterface
  return thl;
}
static const IntrospectionRegistry __aida_aux_data_srvt__InterfaceTests_AnotherChild_ = {
  "InterfaceTests::AnotherChild\0"
  "INTERFACE\0"
  ""};
const Aida::StringVector&
I_AnotherChildIface::__aida_aux_data__() const
{
  static const Aida::StringVector __d_ =
    ::Aida::aux_vectors_combine (IntrospectionRegistry::lookup ("InterfaceTests::AnotherChild"),
                                 this->I_SignalTestInterfaceIface::__aida_aux_data__());
  return __d_;
}
std::vector<std::string>
I_AnotherChildIface::__aida_dir__ () const
{
  std::vector<std::string> __d_;
  { const Aida::StringVector &__t_ = this->I_SignalTestInterfaceIface::__aida_dir__();
    __d_.insert (__d_.end(), __t_.begin(), __t_.end()); }
  return __d_;
}
Aida::Any
I_AnotherChildIface::__aida_get__ (const std::string &__n_) const
{
  Aida::Any __a_;
  __a_ = this->I_SignalTestInterfaceIface::__aida_get__ (__n_); if (__a_.kind()) return __a_;
  return __a_;
}
bool
I_AnotherChildIface::__aida_set__ (const std::string &__n_, const Aida::Any &__a_)
{
  if (this->I_SignalTestInterfaceIface::__aida_set__ (__n_, __a_)) return true;
  return false;
}

I_PropertyTesterIface::I_PropertyTesterIface ()
{}
I_PropertyTesterIface::~I_PropertyTesterIface ()
{} // define empty dtor to emit vtable
void
operator<<= (Aida::ProtoMsg &__p_, const I_PropertyTesterIfaceP &ptr)
{
  __p_ <<= ptr.get();
}
void
operator>>= (Aida::ProtoReader &__f_, I_PropertyTesterIfaceP &obj)
{
  obj = __f_.pop_instance<I_PropertyTesterIface>();
}
void
operator>>= (Aida::ProtoReader &__f_, I_PropertyTesterIface* &obj)
{
  obj = __f_.pop_instance<I_PropertyTesterIface>().get();
}
Aida::TypeHashList
I_PropertyTesterIface::__aida_typelist__ () const
{
  Aida::TypeHashList thl;
  thl.push_back (Aida::TypeHash (0xa37ab462c55a3b3cULL, 0x4f3fd1c9ad9689fbULL)); // PropertyTester
  return thl;
}
static const IntrospectionRegistry __aida_aux_data_srvt__InterfaceTests_PropertyTester_ = {
  "InterfaceTests::PropertyTester\0"
  "INTERFACE\0"
  "bool_prop.type=BOOL\0"
  "int32_prop.type=INT32\0"
  "int64_prop.type=INT64\0"
  "float64_prop.type=FLOAT64\0"
  "string_prop.type=STRING\0"
  "enum_prop.type=ENUM\0"
  "enum_prop.typename=InterfaceTests::QuickEnum\0"
  "record_prop.type=RECORD\0"
  "record_prop.typename=InterfaceTests::QuickRecord\0"
  "sequence_prop.type=SEQUENCE\0"
  "sequence_prop.typename=InterfaceTests::QuickSequence\0"
  "interface_prop.type=INTERFACE\0"
  "interface_prop.typename=InterfaceTests::GrandChild\0"
  "self_prop.type=INTERFACE\0"
  "self_prop.typename=InterfaceTests::PropertyTester\0"
  "any_prop.type=ANY\0"
};
const Aida::StringVector&
I_PropertyTesterIface::__aida_aux_data__() const
{
  static const Aida::StringVector __d_ =
    ::Aida::aux_vectors_combine (IntrospectionRegistry::lookup ("InterfaceTests::PropertyTester"));
  return __d_;
}
std::vector<std::string>
I_PropertyTesterIface::__aida_dir__ () const
{
  std::vector<std::string> __d_;
  __d_.push_back ("bool_prop");
  __d_.push_back ("int32_prop");
  __d_.push_back ("int64_prop");
  __d_.push_back ("float64_prop");
  __d_.push_back ("string_prop");
  __d_.push_back ("enum_prop");
  __d_.push_back ("record_prop");
  __d_.push_back ("sequence_prop");
  __d_.push_back ("interface_prop");
  __d_.push_back ("self_prop");
  __d_.push_back ("any_prop");
  return __d_;
}
Aida::Any
I_PropertyTesterIface::__aida_get__ (const std::string &__n_) const
{
  Aida::Any __a_;
  if (__n_ == "bool_prop")       { __a_.set (bool_prop()); return __a_; }
  if (__n_ == "int32_prop")      { __a_.set (int32_prop()); return __a_; }
  if (__n_ == "int64_prop")      { __a_.set (int64_prop()); return __a_; }
  if (__n_ == "float64_prop")    { __a_.set (float64_prop()); return __a_; }
  if (__n_ == "string_prop")     { __a_.set (string_prop()); return __a_; }
  if (__n_ == "enum_prop")       { __a_.set (enum_prop()); return __a_; }
  if (__n_ == "record_prop")     { __a_.set (record_prop()); return __a_; }
  if (__n_ == "sequence_prop")   { __a_.set (sequence_prop()); return __a_; }
  if (__n_ == "interface_prop")  { __a_.set (interface_prop()); return __a_; }
  if (__n_ == "self_prop")       { __a_.set (self_prop()); return __a_; }
  if (__n_ == "any_prop")        { __a_.set (any_prop()); return __a_; }
  return __a_;
}
bool
I_PropertyTesterIface::__aida_set__ (const std::string &__n_, const Aida::Any &__a_)
{
  if (__n_ == "bool_prop")       { bool_prop (__a_.get<bool>()); return true; }
  if (__n_ == "int32_prop")      { int32_prop (__a_.get<int>()); return true; }
  if (__n_ == "int64_prop")      { int64_prop (__a_.get<int64_t>()); return true; }
  if (__n_ == "float64_prop")    { float64_prop (__a_.get<double>()); return true; }
  if (__n_ == "string_prop")     { string_prop (__a_.get<std::string>()); return true; }
  if (__n_ == "enum_prop")       { enum_prop (__a_.get<QuickEnum>()); return true; }
  if (__n_ == "record_prop")     { record_prop (__a_.get<SrvT_QuickRecord>()); return true; }
  if (__n_ == "sequence_prop")   { sequence_prop (__a_.get<SrvT_QuickSequence>()); return true; }
  if (__n_ == "interface_prop")  { interface_prop (__a_.get<I_GrandChildIfaceP>().get()); return true; }
  if (__n_ == "self_prop")       { self_prop (__a_.get<I_PropertyTesterIfaceP>().get()); return true; }
  if (__n_ == "any_prop")        { any_prop (__a_.get<Aida::Any>()); return true; }
  return false;
}
} // InterfaceTests

namespace RapicornAidaTest {

I_UseIncludesIface::I_UseIncludesIface ()
{}
I_UseIncludesIface::~I_UseIncludesIface ()
{} // define empty dtor to emit vtable
void
operator<<= (Aida::ProtoMsg &__p_, const I_UseIncludesIfaceP &ptr)
{
  __p_ <<= ptr.get();
}
void
operator>>= (Aida::ProtoReader &__f_, I_UseIncludesIfaceP &obj)
{
  obj = __f_.pop_instance<I_UseIncludesIface>();
}
void
operator>>= (Aida::ProtoReader &__f_, I_UseIncludesIface* &obj)
{
  obj = __f_.pop_instance<I_UseIncludesIface>().get();
}
Aida::TypeHashList
I_UseIncludesIface::__aida_typelist__ () const
{
  Aida::TypeHashList thl;
  thl.push_back (Aida::TypeHash (0xfbdf1e0d7f39f4f0ULL, 0x78270f907e3216b4ULL)); // UseIncludes
  thl.push_back (Aida::TypeHash (0xf2af9bb31127c663ULL, 0xa5e510409f8552a5ULL)); // SomeInterface
  return thl;
}
static const IntrospectionRegistry __aida_aux_data_srvt__RapicornAidaTest_UseIncludes_ = {
  "RapicornAidaTest::UseIncludes\0"
  "INTERFACE\0"
  ""};
const Aida::StringVector&
I_UseIncludesIface::__aida_aux_data__() const
{
  static const Aida::StringVector __d_ =
    ::Aida::aux_vectors_combine (IntrospectionRegistry::lookup ("RapicornAidaTest::UseIncludes"),
                                 this->IncludeCheck::I_SomeInterfaceIface::__aida_aux_data__());
  return __d_;
}
std::vector<std::string>
I_UseIncludesIface::__aida_dir__ () const
{
  std::vector<std::string> __d_;
  { const Aida::StringVector &__t_ = this->IncludeCheck::I_SomeInterfaceIface::__aida_dir__();
    __d_.insert (__d_.end(), __t_.begin(), __t_.end()); }
  return __d_;
}
Aida::Any
I_UseIncludesIface::__aida_get__ (const std::string &__n_) const
{
  Aida::Any __a_;
  __a_ = this->IncludeCheck::I_SomeInterfaceIface::__aida_get__ (__n_); if (__a_.kind()) return __a_;
  return __a_;
}
bool
I_UseIncludesIface::__aida_set__ (const std::string &__n_, const Aida::Any &__a_)
{
  if (this->IncludeCheck::I_SomeInterfaceIface::__aida_set__ (__n_, __a_)) return true;
  return false;
}

I_ButtonAreaIface::I_ButtonAreaIface ()
{}
I_ButtonAreaIface::~I_ButtonAreaIface ()
{} // define empty dtor to emit vtable
void
operator<<= (Aida::ProtoMsg &__p_, const I_ButtonAreaIfaceP &ptr)
{
  __p_ <<= ptr.get();
}
void
operator>>= (Aida::ProtoReader &__f_, I_ButtonAreaIfaceP &obj)
{
  obj = __f_.pop_instance<I_ButtonAreaIface>();
}
void
operator>>= (Aida::ProtoReader &__f_, I_ButtonAreaIface* &obj)
{
  obj = __f_.pop_instance<I_ButtonAreaIface>().get();
}
Aida::TypeHashList
I_ButtonAreaIface::__aida_typelist__ () const
{
  Aida::TypeHashList thl;
  thl.push_back (Aida::TypeHash (0xec371b296fa57436ULL, 0x92e4310e386fc92eULL)); // ButtonArea
  return thl;
}
static const IntrospectionRegistry __aida_aux_data_srvt__RapicornAidaTest_ButtonArea_ = {
  "RapicornAidaTest::ButtonArea\0"
  "INTERFACE\0"
  "on_click.type=STRING\0"
  "on_click2.type=STRING\0"
  "on_click3.type=STRING\0"
  "click_type.type=ENUM\0"
  "click_type.typename=RapicornAidaTest::ClickType\0"
};
const Aida::StringVector&
I_ButtonAreaIface::__aida_aux_data__() const
{
  static const Aida::StringVector __d_ =
    ::Aida::aux_vectors_combine (IntrospectionRegistry::lookup ("RapicornAidaTest::ButtonArea"));
  return __d_;
}
std::vector<std::string>
I_ButtonAreaIface::__aida_dir__ () const
{
  std::vector<std::string> __d_;
  __d_.push_back ("on_click");
  __d_.push_back ("on_click2");
  __d_.push_back ("on_click3");
  __d_.push_back ("click_type");
  return __d_;
}
Aida::Any
I_ButtonAreaIface::__aida_get__ (const std::string &__n_) const
{
  Aida::Any __a_;
  if (__n_ == "on_click")        { __a_.set (on_click()); return __a_; }
  if (__n_ == "on_click2")       { __a_.set (on_click2()); return __a_; }
  if (__n_ == "on_click3")       { __a_.set (on_click3()); return __a_; }
  if (__n_ == "click_type")      { __a_.set (click_type()); return __a_; }
  return __a_;
}
bool
I_ButtonAreaIface::__aida_set__ (const std::string &__n_, const Aida::Any &__a_)
{
  if (__n_ == "on_click")        { on_click (__a_.get<std::string>()); return true; }
  if (__n_ == "on_click2")       { on_click2 (__a_.get<std::string>()); return true; }
  if (__n_ == "on_click3")       { on_click3 (__a_.get<std::string>()); return true; }
  if (__n_ == "click_type")      { click_type (__a_.get<ClickType>()); return true; }
  return false;
}

I_PureMethodsIface::I_PureMethodsIface ()
{}
I_PureMethodsIface::~I_PureMethodsIface ()
{} // define empty dtor to emit vtable
void
operator<<= (Aida::ProtoMsg &__p_, const I_PureMethodsIfaceP &ptr)
{
  __p_ <<= ptr.get();
}
void
operator>>= (Aida::ProtoReader &__f_, I_PureMethodsIfaceP &obj)
{
  obj = __f_.pop_instance<I_PureMethodsIface>();
}
void
operator>>= (Aida::ProtoReader &__f_, I_PureMethodsIface* &obj)
{
  obj = __f_.pop_instance<I_PureMethodsIface>().get();
}
Aida::TypeHashList
I_PureMethodsIface::__aida_typelist__ () const
{
  Aida::TypeHashList thl;
  thl.push_back (Aida::TypeHash (0xddc2a514d04d3af5ULL, 0xc0046740434c0486ULL)); // PureMethods
  return thl;
}
static const IntrospectionRegistry __aida_aux_data_srvt__RapicornAidaTest_PureMethods_ = {
  "RapicornAidaTest::PureMethods\0"
  "INTERFACE\0"
  ""};
const Aida::StringVector&
I_PureMethodsIface::__aida_aux_data__() const
{
  static const Aida::StringVector __d_ =
    ::Aida::aux_vectors_combine (IntrospectionRegistry::lookup ("RapicornAidaTest::PureMethods"));
  return __d_;
}
std::vector<std::string>
I_PureMethodsIface::__aida_dir__ () const
{
  std::vector<std::string> __d_;
  return __d_;
}
Aida::Any
I_PureMethodsIface::__aida_get__ (const std::string &__n_) const
{
  Aida::Any __a_;
  return __a_;
}
bool
I_PureMethodsIface::__aida_set__ (const std::string &__n_, const Aida::Any &__a_)
{
  return false;
}
} // RapicornAidaTest

namespace Other {

I_NameTestsIface::I_NameTestsIface ()
{}
I_NameTestsIface::~I_NameTestsIface ()
{} // define empty dtor to emit vtable
void
operator<<= (Aida::ProtoMsg &__p_, const I_NameTestsIfaceP &ptr)
{
  __p_ <<= ptr.get();
}
void
operator>>= (Aida::ProtoReader &__f_, I_NameTestsIfaceP &obj)
{
  obj = __f_.pop_instance<I_NameTestsIface>();
}
void
operator>>= (Aida::ProtoReader &__f_, I_NameTestsIface* &obj)
{
  obj = __f_.pop_instance<I_NameTestsIface>().get();
}
Aida::TypeHashList
I_NameTestsIface::__aida_typelist__ () const
{
  Aida::TypeHashList thl;
  thl.push_back (Aida::TypeHash (0x542d40cd7d8fcd40ULL, 0x8c1782df29c9b936ULL)); // NameTests
  return thl;
}
static const IntrospectionRegistry __aida_aux_data_srvt__Other_NameTests_ = {
  "Other::NameTests\0"
  "INTERFACE\0"
  ""};
const Aida::StringVector&
I_NameTestsIface::__aida_aux_data__() const
{
  static const Aida::StringVector __d_ =
    ::Aida::aux_vectors_combine (IntrospectionRegistry::lookup ("Other::NameTests"));
  return __d_;
}
std::vector<std::string>
I_NameTestsIface::__aida_dir__ () const
{
  std::vector<std::string> __d_;
  return __d_;
}
Aida::Any
I_NameTestsIface::__aida_get__ (const std::string &__n_) const
{
  Aida::Any __a_;
  return __a_;
}
bool
I_NameTestsIface::__aida_set__ (const std::string &__n_, const Aida::Any &__a_)
{
  return false;
}
} // Other

namespace BseTest {

I_CompressorIface::I_CompressorIface ()
{}
I_CompressorIface::~I_CompressorIface ()
{} // define empty dtor to emit vtable
void
operator<<= (Aida::ProtoMsg &__p_, const I_CompressorIfaceP &ptr)
{
  __p_ <<= ptr.get();
}
void
operator>>= (Aida::ProtoReader &__f_, I_CompressorIfaceP &obj)
{
  obj = __f_.pop_instance<I_CompressorIface>();
}
void
operator>>= (Aida::ProtoReader &__f_, I_CompressorIface* &obj)
{
  obj = __f_.pop_instance<I_CompressorIface>().get();
}
Aida::TypeHashList
I_CompressorIface::__aida_typelist__ () const
{
  Aida::TypeHashList thl;
  thl.push_back (Aida::TypeHash (0x42057a05d51182dfULL, 0x6a0d69cda274433eULL)); // Compressor
  return thl;
}
static const IntrospectionRegistry __aida_aux_data_srvt__BseTest_Compressor_ = {
  "BseTest::Compressor\0"
  "INTERFACE\0"
  "threshold.type=FLOAT64\0"
  "threshold.hints=w\0"
  "threshold.default=0\0"
  "threshold.group=Compatibility Settings\0"
  "ratio.type=FLOAT64\0"
  "ratio.hints=w\0"
  "ratio.default=0\0"
  "ratio.group=Compatibility Settings\0"
};
const Aida::StringVector&
I_CompressorIface::__aida_aux_data__() const
{
  static const Aida::StringVector __d_ =
    ::Aida::aux_vectors_combine (IntrospectionRegistry::lookup ("BseTest::Compressor"));
  return __d_;
}
std::vector<std::string>
I_CompressorIface::__aida_dir__ () const
{
  std::vector<std::string> __d_;
  __d_.push_back ("threshold");
  __d_.push_back ("ratio");
  return __d_;
}
Aida::Any
I_CompressorIface::__aida_get__ (const std::string &__n_) const
{
  Aida::Any __a_;
  if (__n_ == "threshold")       { __a_.set (threshold()); return __a_; }
  if (__n_ == "ratio")           { __a_.set (ratio()); return __a_; }
  return __a_;
}
bool
I_CompressorIface::__aida_set__ (const std::string &__n_, const Aida::Any &__a_)
{
  if (__n_ == "threshold")       { threshold (__a_.get<double>()); return true; }
  if (__n_ == "ratio")           { ratio (__a_.get<double>()); return true; }
  return false;
}
static const IntrospectionRegistry __aida_aux_data_srvt__BseTest_RecordForGroups_ = {
  "BseTest::RecordForGroups\0"
  "RECORD\0"
  "i.type=INT32\0"
  "ratio.type=FLOAT64\0"
  "ratio.hints=w\0"
  "ratio.default=0\0"
  "ratio.group=Normal\0"
  "ordinary_bool.type=BOOL\0"
  "threshold1.type=FLOAT64\0"
  "threshold2.type=FLOAT64\0"
};
const Aida::StringVector&
SrvT_RecordForGroups::__aida_aux_data__() const
{
  static const Aida::StringVector sv = IntrospectionRegistry::lookup ("BseTest::RecordForGroups");
  return sv;
}
bool
SrvT_RecordForGroups::operator== (const SrvT_RecordForGroups &other) const
{
  if (this->i != other.i) return false;
  if (this->ratio != other.ratio) return false;
  if (this->ordinary_bool != other.ordinary_bool) return false;
  if (this->threshold1 != other.threshold1) return false;
  if (this->threshold2 != other.threshold2) return false;
  return true;
}
inline void __attribute__ ((used))
operator<<= (Aida::ProtoMsg &dst, const SrvT_RecordForGroups &self)
{
  Aida::ProtoMsg &__p_ = dst.add_rec (5);
  __p_ <<= self.i;
  __p_ <<= self.ratio;
  __p_ <<= self.ordinary_bool;
  __p_ <<= self.threshold1;
  __p_ <<= self.threshold2;
}
inline void __attribute__ ((used))
operator>>= (Aida::ProtoReader &src, SrvT_RecordForGroups &self)
{
  Aida::ProtoReader fbr (src.pop_rec());
  if (fbr.remaining() < 5) return;
  fbr >>= self.i;
  fbr >>= self.ratio;
  fbr >>= self.ordinary_bool;
  fbr >>= self.threshold1;
  fbr >>= self.threshold2;
}

I_SoundModuleIface::I_SoundModuleIface ()
{}
I_SoundModuleIface::~I_SoundModuleIface ()
{} // define empty dtor to emit vtable
void
operator<<= (Aida::ProtoMsg &__p_, const I_SoundModuleIfaceP &ptr)
{
  __p_ <<= ptr.get();
}
void
operator>>= (Aida::ProtoReader &__f_, I_SoundModuleIfaceP &obj)
{
  obj = __f_.pop_instance<I_SoundModuleIface>();
}
void
operator>>= (Aida::ProtoReader &__f_, I_SoundModuleIface* &obj)
{
  obj = __f_.pop_instance<I_SoundModuleIface>().get();
}
Aida::TypeHashList
I_SoundModuleIface::__aida_typelist__ () const
{
  Aida::TypeHashList thl;
  thl.push_back (Aida::TypeHash (0x06447b38b51e0198ULL, 0x848669199cc311deULL)); // SoundModule
  return thl;
}
static const IntrospectionRegistry __aida_aux_data_srvt__BseTest_SoundModule_ = {
  "BseTest::SoundModule\0"
  "INTERFACE\0"
  ""};
const Aida::StringVector&
I_SoundModuleIface::__aida_aux_data__() const
{
  static const Aida::StringVector __d_ =
    ::Aida::aux_vectors_combine (IntrospectionRegistry::lookup ("BseTest::SoundModule"));
  return __d_;
}
std::vector<std::string>
I_SoundModuleIface::__aida_dir__ () const
{
  std::vector<std::string> __d_;
  return __d_;
}
Aida::Any
I_SoundModuleIface::__aida_get__ (const std::string &__n_) const
{
  Aida::Any __a_;
  return __a_;
}
bool
I_SoundModuleIface::__aida_set__ (const std::string &__n_, const Aida::Any &__a_)
{
  return false;
}
} // BseTest

#ifndef __ENUMCC__aidacc_tests_t304_testpass_idl__
#define __ENUMCC__aidacc_tests_t304_testpass_idl__    2
#endif
#if     __ENUMCC__aidacc_tests_t304_testpass_idl__ == 2

namespace Aida {

static const IntrospectionRegistry __aida_aux_data_srvt__MandatoryNamespace_Enum1_ = {
  "MandatoryNamespace::Enum1\0"
  "ENUM\0"
  "E1_A.value=1\0"
};
template<> const EnumInfo&
enum_info<MandatoryNamespace::Enum1> ()
{
  static const EnumValue _aida_enumvalues_1001[] = {
    { int64_t (MandatoryNamespace::Enum1::E1_A), "E1_A", NULL, NULL },
  };
  return ::Aida::EnumInfo::cached_enum_info ("MandatoryNamespace::Enum1", 0, _aida_enumvalues_1001);
} // specialization
template const EnumInfo& enum_info<MandatoryNamespace::Enum1> (); // instantiation

static const IntrospectionRegistry __aida_aux_data_srvt__MandatoryNamespace_Enum1c_ = {
  "MandatoryNamespace::Enum1c\0"
  "ENUM\0"
  "E1C_A.value=1\0"
};
template<> const EnumInfo&
enum_info<MandatoryNamespace::Enum1c> ()
{
  static const EnumValue _aida_enumvalues_1002[] = {
    { int64_t (MandatoryNamespace::Enum1c::E1C_A), "E1C_A", NULL, NULL },
  };
  return ::Aida::EnumInfo::cached_enum_info ("MandatoryNamespace::Enum1c", 0, _aida_enumvalues_1002);
} // specialization
template const EnumInfo& enum_info<MandatoryNamespace::Enum1c> (); // instantiation

static const IntrospectionRegistry __aida_aux_data_srvt__MandatoryNamespace_Enum2_ = {
  "MandatoryNamespace::Enum2\0"
  "ENUM\0"
  "E2_A.value=1\0"
  "E2_B.value=2\0"
};
template<> const EnumInfo&
enum_info<MandatoryNamespace::Enum2> ()
{
  static const EnumValue _aida_enumvalues_1003[] = {
    { int64_t (MandatoryNamespace::Enum2::E2_A), "E2_A", NULL, NULL },
    { int64_t (MandatoryNamespace::Enum2::E2_B), "E2_B", NULL, NULL },
  };
  return ::Aida::EnumInfo::cached_enum_info ("MandatoryNamespace::Enum2", 0, _aida_enumvalues_1003);
} // specialization
template const EnumInfo& enum_info<MandatoryNamespace::Enum2> (); // instantiation

static const IntrospectionRegistry __aida_aux_data_srvt__MandatoryNamespace_Enum2c_ = {
  "MandatoryNamespace::Enum2c\0"
  "ENUM\0"
  "E2C_A.value=1\0"
  "E2C_B.value=2\0"
};
template<> const EnumInfo&
enum_info<MandatoryNamespace::Enum2c> ()
{
  static const EnumValue _aida_enumvalues_1004[] = {
    { int64_t (MandatoryNamespace::Enum2c::E2C_A), "E2C_A", NULL, NULL },
    { int64_t (MandatoryNamespace::Enum2c::E2C_B), "E2C_B", NULL, NULL },
  };
  return ::Aida::EnumInfo::cached_enum_info ("MandatoryNamespace::Enum2c", 0, _aida_enumvalues_1004);
} // specialization
template const EnumInfo& enum_info<MandatoryNamespace::Enum2c> (); // instantiation

static const IntrospectionRegistry __aida_aux_data_srvt__MandatoryNamespace_Enum3_ = {
  "MandatoryNamespace::Enum3\0"
  "ENUM\0"
  "E3_A.value=1\0"
  "E3_B.value=2\0"
  "E3_C.value=3\0"
};
template<> const EnumInfo&
enum_info<MandatoryNamespace::Enum3> ()
{
  static const EnumValue _aida_enumvalues_1005[] = {
    { int64_t (MandatoryNamespace::Enum3::E3_A), "E3_A", NULL, NULL },
    { int64_t (MandatoryNamespace::Enum3::E3_B), "E3_B", NULL, NULL },
    { int64_t (MandatoryNamespace::Enum3::E3_C), "E3_C", NULL, NULL },
  };
  return ::Aida::EnumInfo::cached_enum_info ("MandatoryNamespace::Enum3", 0, _aida_enumvalues_1005);
} // specialization
template const EnumInfo& enum_info<MandatoryNamespace::Enum3> (); // instantiation

static const IntrospectionRegistry __aida_aux_data_srvt__MandatoryNamespace_Enum3c_ = {
  "MandatoryNamespace::Enum3c\0"
  "ENUM\0"
  "E3C_A.value=1\0"
  "E3C_B.value=2\0"
  "E3C_C.value=3\0"
};
template<> const EnumInfo&
enum_info<MandatoryNamespace::Enum3c> ()
{
  static const EnumValue _aida_enumvalues_1006[] = {
    { int64_t (MandatoryNamespace::Enum3c::E3C_A), "E3C_A", NULL, NULL },
    { int64_t (MandatoryNamespace::Enum3c::E3C_B), "E3C_B", NULL, NULL },
    { int64_t (MandatoryNamespace::Enum3c::E3C_C), "E3C_C", NULL, NULL },
  };
  return ::Aida::EnumInfo::cached_enum_info ("MandatoryNamespace::Enum3c", 0, _aida_enumvalues_1006);
} // specialization
template const EnumInfo& enum_info<MandatoryNamespace::Enum3c> (); // instantiation

static const IntrospectionRegistry __aida_aux_data_srvt__MandatoryNamespace_Enum4a_ = {
  "MandatoryNamespace::Enum4a\0"
  "ENUM\0"
  "E4A_A.value=1\0"
  "E4A_B.value=2\0"
  "E4A_C.value=3\0"
  "E4A_D.value=4\0"
};
template<> const EnumInfo&
enum_info<MandatoryNamespace::Enum4a> ()
{
  static const EnumValue _aida_enumvalues_1007[] = {
    { int64_t (MandatoryNamespace::Enum4a::E4A_A), "E4A_A", NULL, NULL },
    { int64_t (MandatoryNamespace::Enum4a::E4A_B), "E4A_B", NULL, NULL },
    { int64_t (MandatoryNamespace::Enum4a::E4A_C), "E4A_C", NULL, NULL },
    { int64_t (MandatoryNamespace::Enum4a::E4A_D), "E4A_D", NULL, NULL },
  };
  return ::Aida::EnumInfo::cached_enum_info ("MandatoryNamespace::Enum4a", 0, _aida_enumvalues_1007);
} // specialization
template const EnumInfo& enum_info<MandatoryNamespace::Enum4a> (); // instantiation

static const IntrospectionRegistry __aida_aux_data_srvt__MandatoryNamespace_Enum4b_ = {
  "MandatoryNamespace::Enum4b\0"
  "ENUM\0"
  "E4B_A.value=1\0"
  "E4B_B.value=2\0"
  "E4B_C.value=3\0"
  "E4B_D.value=4\0"
};
template<> const EnumInfo&
enum_info<MandatoryNamespace::Enum4b> ()
{
  static const EnumValue _aida_enumvalues_1008[] = {
    { int64_t (MandatoryNamespace::Enum4b::E4B_A), "E4B_A", NULL, NULL },
    { int64_t (MandatoryNamespace::Enum4b::E4B_B), "E4B_B", NULL, NULL },
    { int64_t (MandatoryNamespace::Enum4b::E4B_C), "E4B_C", NULL, NULL },
    { int64_t (MandatoryNamespace::Enum4b::E4B_D), "E4B_D", NULL, NULL },
  };
  return ::Aida::EnumInfo::cached_enum_info ("MandatoryNamespace::Enum4b", 0, _aida_enumvalues_1008);
} // specialization
template const EnumInfo& enum_info<MandatoryNamespace::Enum4b> (); // instantiation

static const IntrospectionRegistry __aida_aux_data_srvt__MandatoryNamespace_Enum4c_ = {
  "MandatoryNamespace::Enum4c\0"
  "ENUM\0"
  "E4C_A.value=1\0"
  "E4C_B.value=2\0"
  "E4C_C.value=3\0"
  "E4C_D.value=4\0"
};
template<> const EnumInfo&
enum_info<MandatoryNamespace::Enum4c> ()
{
  static const EnumValue _aida_enumvalues_1009[] = {
    { int64_t (MandatoryNamespace::Enum4c::E4C_A), "E4C_A", NULL, NULL },
    { int64_t (MandatoryNamespace::Enum4c::E4C_B), "E4C_B", NULL, NULL },
    { int64_t (MandatoryNamespace::Enum4c::E4C_C), "E4C_C", NULL, NULL },
    { int64_t (MandatoryNamespace::Enum4c::E4C_D), "E4C_D", NULL, NULL },
  };
  return ::Aida::EnumInfo::cached_enum_info ("MandatoryNamespace::Enum4c", 0, _aida_enumvalues_1009);
} // specialization
template const EnumInfo& enum_info<MandatoryNamespace::Enum4c> (); // instantiation

static const IntrospectionRegistry __aida_aux_data_srvt__MandatoryNamespace_Enum4d_ = {
  "MandatoryNamespace::Enum4d\0"
  "ENUM\0"
  "E4D_A.value=1\0"
  "E4D_B.value=2\0"
  "E4D_C.value=3\0"
  "E4D_D.value=4\0"
};
template<> const EnumInfo&
enum_info<MandatoryNamespace::Enum4d> ()
{
  static const EnumValue _aida_enumvalues_1010[] = {
    { int64_t (MandatoryNamespace::Enum4d::E4D_A), "E4D_A", NULL, NULL },
    { int64_t (MandatoryNamespace::Enum4d::E4D_B), "E4D_B", NULL, NULL },
    { int64_t (MandatoryNamespace::Enum4d::E4D_C), "E4D_C", NULL, NULL },
    { int64_t (MandatoryNamespace::Enum4d::E4D_D), "E4D_D", NULL, NULL },
  };
  return ::Aida::EnumInfo::cached_enum_info ("MandatoryNamespace::Enum4d", 0, _aida_enumvalues_1010);
} // specialization
template const EnumInfo& enum_info<MandatoryNamespace::Enum4d> (); // instantiation

static const IntrospectionRegistry __aida_aux_data_srvt__MandatoryNamespace_ExtensiveEnum_ = {
  "MandatoryNamespace::ExtensiveEnum\0"
  "ENUM\0"
  "V1a.value=1\0"
  "V1b.value=1\0"
  "V2.value=2\0"
  "V3.value=3\0"
  "V3.label=" "v3" "\0"
  "V4.value=4\0"
  "V4.label=" _("v4") "\0"
  "V5.value=5\0"
  "V5.label=" "v5" "\0"
  "V5.blurb=" "V5" "\0"
  "V6.value=6\0"
  "V6.label=" _("v6") "\0"
  "V6.blurb=" "V6" "\0"
  "V7.value=7\0"
  "V7.label=" "v7" "\0"
  "V7.blurb=" _("V7") "\0"
  "V8.value=8\0"
  "V8.label=" _("v8") "\0"
  "V8.blurb=" _("V8") "\0"
  "V9.value=9\0"
  "V10.value=10\0"
  "V10.label=" "v10" "\0"
  "V11.value=11\0"
  "V11.label=" _("v11") "\0"
  "V12.value=12\0"
  "V12.label=" "v12" "\0"
  "V13.value=13\0"
  "V14.value=14\0"
  "V14.label=" _("v14") "\0"
  "V15.value=15\0"
  "V15.label=" "v15" "\0"
  "V15.blurb=" "V15" "\0"
  "V16.value=16\0"
  "V16.label=" _("v16") "\0"
  "V16.blurb=" "V16" "\0"
  "V17.value=17\0"
  "V17.label=" "v17" "\0"
  "V17.blurb=" _("V17") "\0"
  "V18.value=18\0"
  "V18.label=" _("v18") "\0"
  "V18.blurb=" _("V18") "\0"
  "V20.value=20\0"
  "V21.value=21\0"
  "V22.value=22\0"
  "V23.value=23\0"
  "V24.value=24\0"
  "V25.value=-9223372036854775808\0"
  "V26.value=9223372036854775807\0"
  "V27.value=9223372036854775807\0"
  "V28.value=-28\0"
  "V30.value=42\0"
  "V31.value=43\0"
  "V31.label=" "foo" "\0"
  "V32.value=42\0"
  "V33.value=43\0"
  "V33.label=" "foo" "\0"
  "V34.value=44\0"
  "V34.label=" "foo" "\0"
  "V34.blurb=" "foo" "\0"
  "V35.value=42\0"
  "V35.label=" "foo" "\0"
  "V36.value=42\0"
  "V36.label=" "foo" "\0"
  "V36.blurb=" "foo4" "\0"
};
template<> const EnumInfo&
enum_info<MandatoryNamespace::ExtensiveEnum> ()
{
  static const EnumValue _aida_enumvalues_1011[] = {
    { int64_t (MandatoryNamespace::ExtensiveEnum::V1a), "V1a", NULL, NULL },
    { int64_t (MandatoryNamespace::ExtensiveEnum::V1b), "V1b", NULL, NULL },
    { int64_t (MandatoryNamespace::ExtensiveEnum::V2), "V2", NULL, NULL },
    { int64_t (MandatoryNamespace::ExtensiveEnum::V3), "V3", "v3", NULL },
    { int64_t (MandatoryNamespace::ExtensiveEnum::V4), "V4", _("v4"), NULL },
    { int64_t (MandatoryNamespace::ExtensiveEnum::V5), "V5", "v5", "V5" },
    { int64_t (MandatoryNamespace::ExtensiveEnum::V6), "V6", _("v6"), "V6" },
    { int64_t (MandatoryNamespace::ExtensiveEnum::V7), "V7", "v7", _("V7") },
    { int64_t (MandatoryNamespace::ExtensiveEnum::V8), "V8", _("v8"), _("V8") },
    { int64_t (MandatoryNamespace::ExtensiveEnum::V9), "V9", NULL, NULL },
    { int64_t (MandatoryNamespace::ExtensiveEnum::V10), "V10", "v10", NULL },
    { int64_t (MandatoryNamespace::ExtensiveEnum::V11), "V11", _("v11"), NULL },
    { int64_t (MandatoryNamespace::ExtensiveEnum::V12), "V12", "v12", NULL },
    { int64_t (MandatoryNamespace::ExtensiveEnum::V13), "V13", NULL, NULL },
    { int64_t (MandatoryNamespace::ExtensiveEnum::V14), "V14", _("v14"), NULL },
    { int64_t (MandatoryNamespace::ExtensiveEnum::V15), "V15", "v15", "V15" },
    { int64_t (MandatoryNamespace::ExtensiveEnum::V16), "V16", _("v16"), "V16" },
    { int64_t (MandatoryNamespace::ExtensiveEnum::V17), "V17", "v17", _("V17") },
    { int64_t (MandatoryNamespace::ExtensiveEnum::V18), "V18", _("v18"), _("V18") },
    { int64_t (MandatoryNamespace::ExtensiveEnum::V20), "V20", NULL, NULL },
    { int64_t (MandatoryNamespace::ExtensiveEnum::V21), "V21", NULL, NULL },
    { int64_t (MandatoryNamespace::ExtensiveEnum::V22), "V22", NULL, NULL },
    { int64_t (MandatoryNamespace::ExtensiveEnum::V23), "V23", NULL, NULL },
    { int64_t (MandatoryNamespace::ExtensiveEnum::V24), "V24", NULL, NULL },
    { int64_t (MandatoryNamespace::ExtensiveEnum::V25), "V25", NULL, NULL },
    { int64_t (MandatoryNamespace::ExtensiveEnum::V26), "V26", NULL, NULL },
    { int64_t (MandatoryNamespace::ExtensiveEnum::V27), "V27", NULL, NULL },
    { int64_t (MandatoryNamespace::ExtensiveEnum::V28), "V28", NULL, NULL },
    { int64_t (MandatoryNamespace::ExtensiveEnum::V30), "V30", NULL, NULL },
    { int64_t (MandatoryNamespace::ExtensiveEnum::V31), "V31", "foo", NULL },
    { int64_t (MandatoryNamespace::ExtensiveEnum::V32), "V32", NULL, NULL },
    { int64_t (MandatoryNamespace::ExtensiveEnum::V33), "V33", "foo", NULL },
    { int64_t (MandatoryNamespace::ExtensiveEnum::V34), "V34", "foo", "foo" },
    { int64_t (MandatoryNamespace::ExtensiveEnum::V35), "V35", "foo", NULL },
    { int64_t (MandatoryNamespace::ExtensiveEnum::V36), "V36", "foo", "foo4" },
  };
  return ::Aida::EnumInfo::cached_enum_info ("MandatoryNamespace::ExtensiveEnum", 0, _aida_enumvalues_1011);
} // specialization
template const EnumInfo& enum_info<MandatoryNamespace::ExtensiveEnum> (); // instantiation

static const IntrospectionRegistry __aida_aux_data_srvt__InterfaceTests_QuickEnum_ = {
  "InterfaceTests::QuickEnum\0"
  "ENUM\0"
  "ZERO.value=0\0"
};
template<> const EnumInfo&
enum_info<InterfaceTests::QuickEnum> ()
{
  static const EnumValue _aida_enumvalues_1012[] = {
    { int64_t (InterfaceTests::QuickEnum::ZERO), "ZERO", NULL, NULL },
  };
  return ::Aida::EnumInfo::cached_enum_info ("InterfaceTests::QuickEnum", 0, _aida_enumvalues_1012);
} // specialization
template const EnumInfo& enum_info<InterfaceTests::QuickEnum> (); // instantiation

static const IntrospectionRegistry __aida_aux_data_srvt__RapicornAidaTest_ClickType_ = {
  "RapicornAidaTest::ClickType\0"
  "ENUM\0"
  "CLICK_ON_PRESS.value=1\0"
  "CLICK_ON_RELEASE.value=2\0"
  "CLICK_SLOW_REPEAT.value=3\0"
  "CLICK_FAST_REPEAT.value=4\0"
  "CLICK_KEY_REPEAT.value=5\0"
};
template<> const EnumInfo&
enum_info<RapicornAidaTest::ClickType> ()
{
  static const EnumValue _aida_enumvalues_1013[] = {
    { int64_t (RapicornAidaTest::ClickType::CLICK_ON_PRESS), "CLICK_ON_PRESS", NULL, NULL },
    { int64_t (RapicornAidaTest::ClickType::CLICK_ON_RELEASE), "CLICK_ON_RELEASE", NULL, NULL },
    { int64_t (RapicornAidaTest::ClickType::CLICK_SLOW_REPEAT), "CLICK_SLOW_REPEAT", NULL, NULL },
    { int64_t (RapicornAidaTest::ClickType::CLICK_FAST_REPEAT), "CLICK_FAST_REPEAT", NULL, NULL },
    { int64_t (RapicornAidaTest::ClickType::CLICK_KEY_REPEAT), "CLICK_KEY_REPEAT", NULL, NULL },
  };
  return ::Aida::EnumInfo::cached_enum_info ("RapicornAidaTest::ClickType", 0, _aida_enumvalues_1013);
} // specialization
template const EnumInfo& enum_info<RapicornAidaTest::ClickType> (); // instantiation

static const IntrospectionRegistry __aida_aux_data_srvt__RapicornAidaTest_MathExpressions_ = {
  "RapicornAidaTest::MathExpressions\0"
  "ENUM\0"
  "RESULT_2.value=2\0"
  "RESULT_5.value=5\0"
  "RESULT_8.value=8\0"
  "RESULT_6.value=6\0"
  "RESULT_7.value=7\0"
  "RESULT_16.value=16\0"
  "RESULT_3.value=3\0"
  "RESULT_24.value=24\0"
  "RESULT_13.value=13\0"
  "RESULT_m2.value=-2\0"
  "RESULT_77.value=77\0"
  "RESULT_511.value=511\0"
};
template<> const EnumInfo&
enum_info<RapicornAidaTest::MathExpressions> ()
{
  static const EnumValue _aida_enumvalues_1014[] = {
    { int64_t (RapicornAidaTest::MathExpressions::RESULT_2), "RESULT_2", NULL, NULL },
    { int64_t (RapicornAidaTest::MathExpressions::RESULT_5), "RESULT_5", NULL, NULL },
    { int64_t (RapicornAidaTest::MathExpressions::RESULT_8), "RESULT_8", NULL, NULL },
    { int64_t (RapicornAidaTest::MathExpressions::RESULT_6), "RESULT_6", NULL, NULL },
    { int64_t (RapicornAidaTest::MathExpressions::RESULT_7), "RESULT_7", NULL, NULL },
    { int64_t (RapicornAidaTest::MathExpressions::RESULT_16), "RESULT_16", NULL, NULL },
    { int64_t (RapicornAidaTest::MathExpressions::RESULT_3), "RESULT_3", NULL, NULL },
    { int64_t (RapicornAidaTest::MathExpressions::RESULT_24), "RESULT_24", NULL, NULL },
    { int64_t (RapicornAidaTest::MathExpressions::RESULT_13), "RESULT_13", NULL, NULL },
    { int64_t (RapicornAidaTest::MathExpressions::RESULT_m2), "RESULT_m2", NULL, NULL },
    { int64_t (RapicornAidaTest::MathExpressions::RESULT_77), "RESULT_77", NULL, NULL },
    { int64_t (RapicornAidaTest::MathExpressions::RESULT_511), "RESULT_511", NULL, NULL },
  };
  return ::Aida::EnumInfo::cached_enum_info ("RapicornAidaTest::MathExpressions", 0, _aida_enumvalues_1014);
} // specialization
template const EnumInfo& enum_info<RapicornAidaTest::MathExpressions> (); // instantiation
} // Aida

#endif // __ENUMCC__aidacc_tests_t304_testpass_idl__


// --- Method Dispatchers & Registry ---

namespace MandatoryNamespace {
static Aida::ProtoMsg*
__aida_call__FirstInterface__void_func (Aida::ProtoReader &fbr)
{
  AIDA_ASSERT_RETURN (fbr.remaining() == 3 + 1 + 0, NULL);
  I_FirstInterfaceIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_ASSERT_RETURN (self != NULL, NULL);
  self->void_func ();
  return NULL;
}


namespace Inner {
} // Inner
} // MandatoryNamespace

namespace OtherNamespace {
} // OtherNamespace

namespace Auxdata {
} // Auxdata

namespace InterfaceTests {
static Aida::ProtoMsg*
__aida_get__UIWidgetArea__dummy (Aida::ProtoReader &fbr)
{
  AIDA_ASSERT_RETURN (fbr.remaining() == 3 + 1, NULL);
  I_UIWidgetAreaIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_ASSERT_RETURN (self != NULL, NULL);
  bool rval = self->dummy ();
  Aida::ProtoMsg &rb = *__AIDA_Local__::new_call_result (fbr, 0xf67db704b9d460d6ULL, 0xd4950feab697e61eULL);
  rb <<= rval;
  return &rb;
}
static Aida::ProtoMsg*
__aida_set__UIWidgetArea__dummy (Aida::ProtoReader &fbr)
{
  AIDA_ASSERT_RETURN (fbr.remaining() == 3 + 1 + 1, NULL);
  I_UIWidgetAreaIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_ASSERT_RETURN (self != NULL, NULL);
  bool  arg_dummy;
  fbr >>= arg_dummy;
  self->dummy (arg_dummy);
  return NULL;
}
static Aida::ProtoMsg*
__aida_get__UIWidgetArea__on_click (Aida::ProtoReader &fbr)
{
  AIDA_ASSERT_RETURN (fbr.remaining() == 3 + 1, NULL);
  I_UIWidgetAreaIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_ASSERT_RETURN (self != NULL, NULL);
  std::string rval = self->on_click ();
  Aida::ProtoMsg &rb = *__AIDA_Local__::new_call_result (fbr, 0x58ba68f6b64584c9ULL, 0xa7d2686edb40f27aULL);
  rb <<= rval;
  return &rb;
}
static Aida::ProtoMsg*
__aida_set__UIWidgetArea__on_click (Aida::ProtoReader &fbr)
{
  AIDA_ASSERT_RETURN (fbr.remaining() == 3 + 1 + 1, NULL);
  I_UIWidgetAreaIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_ASSERT_RETURN (self != NULL, NULL);
  std::string  arg_on_click;
  fbr >>= arg_on_click;
  self->on_click (arg_on_click);
  return NULL;
}
static Aida::ProtoMsg*
__aida_call__UIWidgetArea__simple_method (Aida::ProtoReader &fbr)
{
  AIDA_ASSERT_RETURN (fbr.remaining() == 3 + 1 + 0, NULL);
  I_UIWidgetAreaIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_ASSERT_RETURN (self != NULL, NULL);
  double rval = self->simple_method ();
  Aida::ProtoMsg &rb = *__AIDA_Local__::new_call_result (fbr, 0xd0dd4c08ba5022c0ULL, 0xb1af31ca1ec7037aULL);
  rb <<= rval;
  return &rb;
}
static Aida::ProtoMsg*
__aida_call__UIWidgetArea__single_arg (Aida::ProtoReader &fbr)
{
  AIDA_ASSERT_RETURN (fbr.remaining() == 3 + 1 + 1, NULL);
  I_UIWidgetAreaIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_ASSERT_RETURN (self != NULL, NULL);
  int  arg_n;
  fbr >>= arg_n;
  double rval = self->single_arg (arg_n);
  Aida::ProtoMsg &rb = *__AIDA_Local__::new_call_result (fbr, 0xe4e890540b4c0579ULL, 0xe14a7ffaa82f1c4fULL);
  rb <<= rval;
  return &rb;
}
static Aida::ProtoMsg*
__aida_call__UIWidgetArea__single_arg2 (Aida::ProtoReader &fbr)
{
  AIDA_ASSERT_RETURN (fbr.remaining() == 3 + 1 + 1, NULL);
  I_UIWidgetAreaIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_ASSERT_RETURN (self != NULL, NULL);
  int  arg_n;
  fbr >>= arg_n;
  double rval = self->single_arg2 (arg_n);
  Aida::ProtoMsg &rb = *__AIDA_Local__::new_call_result (fbr, 0x9cfaa316ccbb6ea0ULL, 0x6cc5207c5520e081ULL);
  rb <<= rval;
  return &rb;
}
static Aida::ProtoMsg*
__aida_call__UIWidgetArea__two_args (Aida::ProtoReader &fbr)
{
  AIDA_ASSERT_RETURN (fbr.remaining() == 3 + 1 + 2, NULL);
  I_UIWidgetAreaIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_ASSERT_RETURN (self != NULL, NULL);
  int  arg_n;
  fbr >>= arg_n;
  double  arg_r;
  fbr >>= arg_r;
  double rval = self->two_args (arg_n, arg_r);
  Aida::ProtoMsg &rb = *__AIDA_Local__::new_call_result (fbr, 0x64511c410b16c274ULL, 0x19b47eb22b4cd4d4ULL);
  rb <<= rval;
  return &rb;
}
static Aida::ProtoMsg*
__aida_call__UIWidgetArea__two_args2 (Aida::ProtoReader &fbr)
{
  AIDA_ASSERT_RETURN (fbr.remaining() == 3 + 1 + 2, NULL);
  I_UIWidgetAreaIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_ASSERT_RETURN (self != NULL, NULL);
  int  arg_n;
  fbr >>= arg_n;
  double  arg_r;
  fbr >>= arg_r;
  double rval = self->two_args2 (arg_n, arg_r);
  Aida::ProtoMsg &rb = *__AIDA_Local__::new_call_result (fbr, 0x2089150ae3f7ad80ULL, 0xe6154471cb4560e0ULL);
  rb <<= rval;
  return &rb;
}
static Aida::ProtoMsg*
__aida_call__UIWidgetArea__multi_args (Aida::ProtoReader &fbr)
{
  AIDA_ASSERT_RETURN (fbr.remaining() == 3 + 1 + 6, NULL);
  I_UIWidgetAreaIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_ASSERT_RETURN (self != NULL, NULL);
  bool  arg_b;
  fbr >>= arg_b;
  int64_t  arg_n;
  fbr >>= arg_n;
  double  arg_r;
  fbr >>= arg_r;
  int  arg_i;
  fbr >>= arg_i;
  std::string  arg_s;
  fbr >>= arg_s;
  double  arg_y;
  fbr >>= arg_y;
  double rval = self->multi_args (arg_b, arg_n, arg_r, arg_i, arg_s, arg_y);
  Aida::ProtoMsg &rb = *__AIDA_Local__::new_call_result (fbr, 0x349f073a5bad36fdULL, 0xf7a10ae13b8e391bULL);
  rb <<= rval;
  return &rb;
}
static Aida::ProtoMsg*
__aida_call__UIWidgetArea__self_method (Aida::ProtoReader &fbr)
{
  AIDA_ASSERT_RETURN (fbr.remaining() == 3 + 1 + 2, NULL);
  I_UIWidgetAreaIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_ASSERT_RETURN (self != NULL, NULL);
  I_UIWidgetAreaIface *arg_ba1;
  fbr >>= arg_ba1;
  I_UIWidgetAreaIface *arg_ba2;
  fbr >>= arg_ba2;
  double rval = self->self_method (*arg_ba1, *arg_ba2);
  Aida::ProtoMsg &rb = *__AIDA_Local__::new_call_result (fbr, 0x4b479b2f4e3ba551ULL, 0xb7c407eee57eb21aULL);
  rb <<= rval;
  return &rb;
}
static Aida::ProtoMsg*
__aida_call__UIWidgetArea__void_method (Aida::ProtoReader &fbr)
{
  AIDA_ASSERT_RETURN (fbr.remaining() == 3 + 1 + 0, NULL);
  I_UIWidgetAreaIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_ASSERT_RETURN (self != NULL, NULL);
  self->void_method ();
  return NULL;
}
static Aida::ProtoMsg*
__aida_call__UIWidgetArea__on_click2out (Aida::ProtoReader &fbr)
{
  AIDA_ASSERT_RETURN (fbr.remaining() == 3 + 1 + 0, NULL);
  I_UIWidgetAreaIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_ASSERT_RETURN (self != NULL, NULL);
  std::string rval = self->on_click2out ();
  Aida::ProtoMsg &rb = *__AIDA_Local__::new_call_result (fbr, 0xb8bc20394724087aULL, 0xbc7b1e7d30aeb178ULL);
  rb <<= rval;
  return &rb;
}
static Aida::ProtoMsg*
__aida_call__UIWidgetArea__on_click2in (Aida::ProtoReader &fbr)
{
  AIDA_ASSERT_RETURN (fbr.remaining() == 3 + 1 + 1, NULL);
  I_UIWidgetAreaIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_ASSERT_RETURN (self != NULL, NULL);
  std::string  arg_command;
  fbr >>= arg_command;
  self->on_click2in (arg_command);
  return NULL;
}





static Aida::ProtoMsg*
__aida_call__QuickIface__simple_function (Aida::ProtoReader &fbr)
{
  AIDA_ASSERT_RETURN (fbr.remaining() == 3 + 1 + 1, NULL);
  I_QuickIfaceIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_ASSERT_RETURN (self != NULL, NULL);
  int  arg_i;
  fbr >>= arg_i;
  self->simple_function (arg_i);
  return NULL;
}

static Aida::ProtoMsg*
__aida_call__MethodTestInterface__method_with_void (Aida::ProtoReader &fbr)
{
  AIDA_ASSERT_RETURN (fbr.remaining() == 3 + 1 + 0, NULL);
  I_MethodTestInterfaceIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_ASSERT_RETURN (self != NULL, NULL);
  self->method_with_void ();
  return NULL;
}
static Aida::ProtoMsg*
__aida_call__MethodTestInterface__method_with_bools (Aida::ProtoReader &fbr)
{
  AIDA_ASSERT_RETURN (fbr.remaining() == 3 + 1 + 2, NULL);
  I_MethodTestInterfaceIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_ASSERT_RETURN (self != NULL, NULL);
  bool  arg_input;
  fbr >>= arg_input;
  bool  arg_optval;
  fbr >>= arg_optval;
  bool rval = self->method_with_bools (arg_input, arg_optval);
  Aida::ProtoMsg &rb = *__AIDA_Local__::new_call_result (fbr, 0x55291a7348d14242ULL, 0x32dac90dde65a764ULL);
  rb <<= rval;
  return &rb;
}
static Aida::ProtoMsg*
__aida_call__MethodTestInterface__method_with_ints32 (Aida::ProtoReader &fbr)
{
  AIDA_ASSERT_RETURN (fbr.remaining() == 3 + 1 + 2, NULL);
  I_MethodTestInterfaceIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_ASSERT_RETURN (self != NULL, NULL);
  int  arg_input;
  fbr >>= arg_input;
  int  arg_optval;
  fbr >>= arg_optval;
  int rval = self->method_with_ints32 (arg_input, arg_optval);
  Aida::ProtoMsg &rb = *__AIDA_Local__::new_call_result (fbr, 0xdc38cf6855c54108ULL, 0x328ddcdcec8f161eULL);
  rb <<= rval;
  return &rb;
}
static Aida::ProtoMsg*
__aida_call__MethodTestInterface__method_with_ints64 (Aida::ProtoReader &fbr)
{
  AIDA_ASSERT_RETURN (fbr.remaining() == 3 + 1 + 2, NULL);
  I_MethodTestInterfaceIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_ASSERT_RETURN (self != NULL, NULL);
  int64_t  arg_input;
  fbr >>= arg_input;
  int64_t  arg_optval;
  fbr >>= arg_optval;
  int64_t rval = self->method_with_ints64 (arg_input, arg_optval);
  Aida::ProtoMsg &rb = *__AIDA_Local__::new_call_result (fbr, 0x678de8636167b6a1ULL, 0xb27d37ca066b5335ULL);
  rb <<= rval;
  return &rb;
}
static Aida::ProtoMsg*
__aida_call__MethodTestInterface__method_with_floats (Aida::ProtoReader &fbr)
{
  AIDA_ASSERT_RETURN (fbr.remaining() == 3 + 1 + 2, NULL);
  I_MethodTestInterfaceIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_ASSERT_RETURN (self != NULL, NULL);
  double  arg_input;
  fbr >>= arg_input;
  double  arg_optval;
  fbr >>= arg_optval;
  double rval = self->method_with_floats (arg_input, arg_optval);
  Aida::ProtoMsg &rb = *__AIDA_Local__::new_call_result (fbr, 0xeea6d5fb184699a3ULL, 0xce05c988a9bfd2d9ULL);
  rb <<= rval;
  return &rb;
}
static Aida::ProtoMsg*
__aida_call__MethodTestInterface__method_with_string (Aida::ProtoReader &fbr)
{
  AIDA_ASSERT_RETURN (fbr.remaining() == 3 + 1 + 2, NULL);
  I_MethodTestInterfaceIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_ASSERT_RETURN (self != NULL, NULL);
  std::string  arg_input;
  fbr >>= arg_input;
  std::string  arg_optval;
  fbr >>= arg_optval;
  std::string rval = self->method_with_string (arg_input, arg_optval);
  Aida::ProtoMsg &rb = *__AIDA_Local__::new_call_result (fbr, 0x646f80849d732dc5ULL, 0x72fd1ede45b153e3ULL);
  rb <<= rval;
  return &rb;
}
static Aida::ProtoMsg*
__aida_call__MethodTestInterface__method_with_enum (Aida::ProtoReader &fbr)
{
  AIDA_ASSERT_RETURN (fbr.remaining() == 3 + 1 + 2, NULL);
  I_MethodTestInterfaceIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_ASSERT_RETURN (self != NULL, NULL);
  QuickEnum  arg_input;
  fbr >>= arg_input;
  QuickEnum  arg_optval;
  fbr >>= arg_optval;
  QuickEnum rval = self->method_with_enum (arg_input, arg_optval);
  Aida::ProtoMsg &rb = *__AIDA_Local__::new_call_result (fbr, 0xee3b0b1c6eb52bdeULL, 0x13729d2db240b4f9ULL);
  rb <<= rval;
  return &rb;
}
static Aida::ProtoMsg*
__aida_call__MethodTestInterface__method_with_record (Aida::ProtoReader &fbr)
{
  AIDA_ASSERT_RETURN (fbr.remaining() == 3 + 1 + 2, NULL);
  I_MethodTestInterfaceIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_ASSERT_RETURN (self != NULL, NULL);
  SrvT_QuickRecord  arg_input;
  fbr >>= arg_input;
  SrvT_QuickRecord  arg_optval;
  fbr >>= arg_optval;
  SrvT_QuickRecord rval = self->method_with_record (arg_input, arg_optval);
  Aida::ProtoMsg &rb = *__AIDA_Local__::new_call_result (fbr, 0x852c7f5942a87cceULL, 0x487dc78cd38240f6ULL);
  rb <<= rval;
  return &rb;
}
static Aida::ProtoMsg*
__aida_call__MethodTestInterface__method_with_sequence (Aida::ProtoReader &fbr)
{
  AIDA_ASSERT_RETURN (fbr.remaining() == 3 + 1 + 2, NULL);
  I_MethodTestInterfaceIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_ASSERT_RETURN (self != NULL, NULL);
  SrvT_QuickSequence  arg_input;
  fbr >>= arg_input;
  SrvT_QuickSequence  arg_optval;
  fbr >>= arg_optval;
  SrvT_QuickSequence rval = self->method_with_sequence (arg_input, arg_optval);
  Aida::ProtoMsg &rb = *__AIDA_Local__::new_call_result (fbr, 0x5534838e08bdc63dULL, 0xd852fd5abb88ab7dULL);
  rb <<= rval;
  return &rb;
}
static Aida::ProtoMsg*
__aida_call__MethodTestInterface__method_with_interface (Aida::ProtoReader &fbr)
{
  AIDA_ASSERT_RETURN (fbr.remaining() == 3 + 1 + 2, NULL);
  I_MethodTestInterfaceIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_ASSERT_RETURN (self != NULL, NULL);
  I_GrandChildIface *arg_input;
  fbr >>= arg_input;
  I_GrandChildIface *arg_optval;
  fbr >>= arg_optval;
  I_GrandChildIfaceP rval = self->method_with_interface (*arg_input, *arg_optval);
  Aida::ProtoMsg &rb = *__AIDA_Local__::new_call_result (fbr, 0xfe9af28dc9c5de7dULL, 0x418be0c0e085ea6dULL);
  rb <<= rval;
  return &rb;
}
static Aida::ProtoMsg*
__aida_call__MethodTestInterface__method_with_anys (Aida::ProtoReader &fbr)
{
  AIDA_ASSERT_RETURN (fbr.remaining() == 3 + 1 + 2, NULL);
  I_MethodTestInterfaceIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_ASSERT_RETURN (self != NULL, NULL);
  Aida::Any  arg_input;
  fbr >>= arg_input;
  Aida::Any  arg_optval;
  fbr >>= arg_optval;
  Aida::Any rval = self->method_with_anys (arg_input, arg_optval);
  Aida::ProtoMsg &rb = *__AIDA_Local__::new_call_result (fbr, 0x807e5dacf307a277ULL, 0x2b65069e50e63c80ULL);
  rb <<= rval;
  return &rb;
}
static Aida::ProtoMsg*
__aida_call__MethodTestInterface__method_with_quickiface (Aida::ProtoReader &fbr)
{
  AIDA_ASSERT_RETURN (fbr.remaining() == 3 + 1 + 2, NULL);
  I_MethodTestInterfaceIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_ASSERT_RETURN (self != NULL, NULL);
  I_QuickIfaceIface *arg_input;
  fbr >>= arg_input;
  I_QuickIfaceIface *arg_iface0;
  fbr >>= arg_iface0;
  I_QuickIfaceIfaceP rval = self->method_with_quickiface (*arg_input, *arg_iface0);
  Aida::ProtoMsg &rb = *__AIDA_Local__::new_call_result (fbr, 0xbe67f4e0afeafd68ULL, 0x5cdf24c075b03215ULL);
  rb <<= rval;
  return &rb;
}




static Aida::ProtoMsg*
__aida_get__PropertyTester__bool_prop (Aida::ProtoReader &fbr)
{
  AIDA_ASSERT_RETURN (fbr.remaining() == 3 + 1, NULL);
  I_PropertyTesterIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_ASSERT_RETURN (self != NULL, NULL);
  bool rval = self->bool_prop ();
  Aida::ProtoMsg &rb = *__AIDA_Local__::new_call_result (fbr, 0x14469c03fdfc61e4ULL, 0x3bb8a3b5d9832788ULL);
  rb <<= rval;
  return &rb;
}
static Aida::ProtoMsg*
__aida_set__PropertyTester__bool_prop (Aida::ProtoReader &fbr)
{
  AIDA_ASSERT_RETURN (fbr.remaining() == 3 + 1 + 1, NULL);
  I_PropertyTesterIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_ASSERT_RETURN (self != NULL, NULL);
  bool  arg_bool_prop;
  fbr >>= arg_bool_prop;
  self->bool_prop (arg_bool_prop);
  return NULL;
}
static Aida::ProtoMsg*
__aida_get__PropertyTester__int32_prop (Aida::ProtoReader &fbr)
{
  AIDA_ASSERT_RETURN (fbr.remaining() == 3 + 1, NULL);
  I_PropertyTesterIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_ASSERT_RETURN (self != NULL, NULL);
  int rval = self->int32_prop ();
  Aida::ProtoMsg &rb = *__AIDA_Local__::new_call_result (fbr, 0x8a2f1538f2b852fbULL, 0x7d3e8ea6f069a1c0ULL);
  rb <<= rval;
  return &rb;
}
static Aida::ProtoMsg*
__aida_set__PropertyTester__int32_prop (Aida::ProtoReader &fbr)
{
  AIDA_ASSERT_RETURN (fbr.remaining() == 3 + 1 + 1, NULL);
  I_PropertyTesterIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_ASSERT_RETURN (self != NULL, NULL);
  int  arg_int32_prop;
  fbr >>= arg_int32_prop;
  self->int32_prop (arg_int32_prop);
  return NULL;
}
static Aida::ProtoMsg*
__aida_get__PropertyTester__int64_prop (Aida::ProtoReader &fbr)
{
  AIDA_ASSERT_RETURN (fbr.remaining() == 3 + 1, NULL);
  I_PropertyTesterIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_ASSERT_RETURN (self != NULL, NULL);
  int64_t rval = self->int64_prop ();
  Aida::ProtoMsg &rb = *__AIDA_Local__::new_call_result (fbr, 0xc9bb6114fc5c90deULL, 0x400dff0f59e66f63ULL);
  rb <<= rval;
  return &rb;
}
static Aida::ProtoMsg*
__aida_set__PropertyTester__int64_prop (Aida::ProtoReader &fbr)
{
  AIDA_ASSERT_RETURN (fbr.remaining() == 3 + 1 + 1, NULL);
  I_PropertyTesterIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_ASSERT_RETURN (self != NULL, NULL);
  int64_t  arg_int64_prop;
  fbr >>= arg_int64_prop;
  self->int64_prop (arg_int64_prop);
  return NULL;
}
static Aida::ProtoMsg*
__aida_get__PropertyTester__float64_prop (Aida::ProtoReader &fbr)
{
  AIDA_ASSERT_RETURN (fbr.remaining() == 3 + 1, NULL);
  I_PropertyTesterIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_ASSERT_RETURN (self != NULL, NULL);
  double rval = self->float64_prop ();
  Aida::ProtoMsg &rb = *__AIDA_Local__::new_call_result (fbr, 0xb3d53f6a66ba171eULL, 0xc9e2fe1ad9d2d2abULL);
  rb <<= rval;
  return &rb;
}
static Aida::ProtoMsg*
__aida_set__PropertyTester__float64_prop (Aida::ProtoReader &fbr)
{
  AIDA_ASSERT_RETURN (fbr.remaining() == 3 + 1 + 1, NULL);
  I_PropertyTesterIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_ASSERT_RETURN (self != NULL, NULL);
  double  arg_float64_prop;
  fbr >>= arg_float64_prop;
  self->float64_prop (arg_float64_prop);
  return NULL;
}
static Aida::ProtoMsg*
__aida_get__PropertyTester__string_prop (Aida::ProtoReader &fbr)
{
  AIDA_ASSERT_RETURN (fbr.remaining() == 3 + 1, NULL);
  I_PropertyTesterIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_ASSERT_RETURN (self != NULL, NULL);
  std::string rval = self->string_prop ();
  Aida::ProtoMsg &rb = *__AIDA_Local__::new_call_result (fbr, 0xd11acce29fa83acfULL, 0xb251b5fc0f737558ULL);
  rb <<= rval;
  return &rb;
}
static Aida::ProtoMsg*
__aida_set__PropertyTester__string_prop (Aida::ProtoReader &fbr)
{
  AIDA_ASSERT_RETURN (fbr.remaining() == 3 + 1 + 1, NULL);
  I_PropertyTesterIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_ASSERT_RETURN (self != NULL, NULL);
  std::string  arg_string_prop;
  fbr >>= arg_string_prop;
  self->string_prop (arg_string_prop);
  return NULL;
}
static Aida::ProtoMsg*
__aida_get__PropertyTester__enum_prop (Aida::ProtoReader &fbr)
{
  AIDA_ASSERT_RETURN (fbr.remaining() == 3 + 1, NULL);
  I_PropertyTesterIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_ASSERT_RETURN (self != NULL, NULL);
  QuickEnum rval = self->enum_prop ();
  Aida::ProtoMsg &rb = *__AIDA_Local__::new_call_result (fbr, 0x42f93106aeb5af11ULL, 0xdc4094dc01da9f81ULL);
  rb <<= rval;
  return &rb;
}
static Aida::ProtoMsg*
__aida_set__PropertyTester__enum_prop (Aida::ProtoReader &fbr)
{
  AIDA_ASSERT_RETURN (fbr.remaining() == 3 + 1 + 1, NULL);
  I_PropertyTesterIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_ASSERT_RETURN (self != NULL, NULL);
  QuickEnum  arg_enum_prop;
  fbr >>= arg_enum_prop;
  self->enum_prop (arg_enum_prop);
  return NULL;
}
static Aida::ProtoMsg*
__aida_get__PropertyTester__record_prop (Aida::ProtoReader &fbr)
{
  AIDA_ASSERT_RETURN (fbr.remaining() == 3 + 1, NULL);
  I_PropertyTesterIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_ASSERT_RETURN (self != NULL, NULL);
  SrvT_QuickRecord rval = self->record_prop ();
  Aida::ProtoMsg &rb = *__AIDA_Local__::new_call_result (fbr, 0xb6ab96740d7834eeULL, 0xe7873bec722bb0c8ULL);
  rb <<= rval;
  return &rb;
}
static Aida::ProtoMsg*
__aida_set__PropertyTester__record_prop (Aida::ProtoReader &fbr)
{
  AIDA_ASSERT_RETURN (fbr.remaining() == 3 + 1 + 1, NULL);
  I_PropertyTesterIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_ASSERT_RETURN (self != NULL, NULL);
  SrvT_QuickRecord  arg_record_prop;
  fbr >>= arg_record_prop;
  self->record_prop (arg_record_prop);
  return NULL;
}
static Aida::ProtoMsg*
__aida_get__PropertyTester__sequence_prop (Aida::ProtoReader &fbr)
{
  AIDA_ASSERT_RETURN (fbr.remaining() == 3 + 1, NULL);
  I_PropertyTesterIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_ASSERT_RETURN (self != NULL, NULL);
  SrvT_QuickSequence rval = self->sequence_prop ();
  Aida::ProtoMsg &rb = *__AIDA_Local__::new_call_result (fbr, 0x7f96e6ff442ecdd5ULL, 0xdb054c03831fd75bULL);
  rb <<= rval;
  return &rb;
}
static Aida::ProtoMsg*
__aida_set__PropertyTester__sequence_prop (Aida::ProtoReader &fbr)
{
  AIDA_ASSERT_RETURN (fbr.remaining() == 3 + 1 + 1, NULL);
  I_PropertyTesterIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_ASSERT_RETURN (self != NULL, NULL);
  SrvT_QuickSequence  arg_sequence_prop;
  fbr >>= arg_sequence_prop;
  self->sequence_prop (arg_sequence_prop);
  return NULL;
}
static Aida::ProtoMsg*
__aida_get__PropertyTester__interface_prop (Aida::ProtoReader &fbr)
{
  AIDA_ASSERT_RETURN (fbr.remaining() == 3 + 1, NULL);
  I_PropertyTesterIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_ASSERT_RETURN (self != NULL, NULL);
  I_GrandChildIfaceP rval = self->interface_prop ();
  Aida::ProtoMsg &rb = *__AIDA_Local__::new_call_result (fbr, 0xf3cef8a00677d931ULL, 0x8733ca529b58ea4aULL);
  rb <<= rval;
  return &rb;
}
static Aida::ProtoMsg*
__aida_set__PropertyTester__interface_prop (Aida::ProtoReader &fbr)
{
  AIDA_ASSERT_RETURN (fbr.remaining() == 3 + 1 + 1, NULL);
  I_PropertyTesterIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_ASSERT_RETURN (self != NULL, NULL);
  I_GrandChildIface *arg_interface_prop;
  fbr >>= arg_interface_prop;
  self->interface_prop (&*arg_interface_prop);
  return NULL;
}
static Aida::ProtoMsg*
__aida_get__PropertyTester__self_prop (Aida::ProtoReader &fbr)
{
  AIDA_ASSERT_RETURN (fbr.remaining() == 3 + 1, NULL);
  I_PropertyTesterIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_ASSERT_RETURN (self != NULL, NULL);
  I_PropertyTesterIfaceP rval = self->self_prop ();
  Aida::ProtoMsg &rb = *__AIDA_Local__::new_call_result (fbr, 0xdd2a04f6c2fc3005ULL, 0x68868b01ea78948fULL);
  rb <<= rval;
  return &rb;
}
static Aida::ProtoMsg*
__aida_set__PropertyTester__self_prop (Aida::ProtoReader &fbr)
{
  AIDA_ASSERT_RETURN (fbr.remaining() == 3 + 1 + 1, NULL);
  I_PropertyTesterIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_ASSERT_RETURN (self != NULL, NULL);
  I_PropertyTesterIface *arg_self_prop;
  fbr >>= arg_self_prop;
  self->self_prop (&*arg_self_prop);
  return NULL;
}
static Aida::ProtoMsg*
__aida_get__PropertyTester__any_prop (Aida::ProtoReader &fbr)
{
  AIDA_ASSERT_RETURN (fbr.remaining() == 3 + 1, NULL);
  I_PropertyTesterIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_ASSERT_RETURN (self != NULL, NULL);
  Aida::Any rval = self->any_prop ();
  Aida::ProtoMsg &rb = *__AIDA_Local__::new_call_result (fbr, 0xb54c6ac2d1c8f932ULL, 0x1c8ea2813f2c268eULL);
  rb <<= rval;
  return &rb;
}
static Aida::ProtoMsg*
__aida_set__PropertyTester__any_prop (Aida::ProtoReader &fbr)
{
  AIDA_ASSERT_RETURN (fbr.remaining() == 3 + 1 + 1, NULL);
  I_PropertyTesterIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_ASSERT_RETURN (self != NULL, NULL);
  Aida::Any  arg_any_prop;
  fbr >>= arg_any_prop;
  self->any_prop (arg_any_prop);
  return NULL;
}

} // InterfaceTests

namespace RapicornAidaTest {

static Aida::ProtoMsg*
__aida_get__ButtonArea__on_click (Aida::ProtoReader &fbr)
{
  AIDA_ASSERT_RETURN (fbr.remaining() == 3 + 1, NULL);
  I_ButtonAreaIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_ASSERT_RETURN (self != NULL, NULL);
  std::string rval = self->on_click ();
  Aida::ProtoMsg &rb = *__AIDA_Local__::new_call_result (fbr, 0x199859aecc756e97ULL, 0xa744332174ed27f4ULL);
  rb <<= rval;
  return &rb;
}
static Aida::ProtoMsg*
__aida_set__ButtonArea__on_click (Aida::ProtoReader &fbr)
{
  AIDA_ASSERT_RETURN (fbr.remaining() == 3 + 1 + 1, NULL);
  I_ButtonAreaIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_ASSERT_RETURN (self != NULL, NULL);
  std::string  arg_on_click;
  fbr >>= arg_on_click;
  self->on_click (arg_on_click);
  return NULL;
}
static Aida::ProtoMsg*
__aida_get__ButtonArea__on_click2 (Aida::ProtoReader &fbr)
{
  AIDA_ASSERT_RETURN (fbr.remaining() == 3 + 1, NULL);
  I_ButtonAreaIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_ASSERT_RETURN (self != NULL, NULL);
  std::string rval = self->on_click2 ();
  Aida::ProtoMsg &rb = *__AIDA_Local__::new_call_result (fbr, 0x1b448d91990181daULL, 0x9751c08ae956c729ULL);
  rb <<= rval;
  return &rb;
}
static Aida::ProtoMsg*
__aida_set__ButtonArea__on_click2 (Aida::ProtoReader &fbr)
{
  AIDA_ASSERT_RETURN (fbr.remaining() == 3 + 1 + 1, NULL);
  I_ButtonAreaIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_ASSERT_RETURN (self != NULL, NULL);
  std::string  arg_on_click2;
  fbr >>= arg_on_click2;
  self->on_click2 (arg_on_click2);
  return NULL;
}
static Aida::ProtoMsg*
__aida_get__ButtonArea__on_click3 (Aida::ProtoReader &fbr)
{
  AIDA_ASSERT_RETURN (fbr.remaining() == 3 + 1, NULL);
  I_ButtonAreaIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_ASSERT_RETURN (self != NULL, NULL);
  std::string rval = self->on_click3 ();
  Aida::ProtoMsg &rb = *__AIDA_Local__::new_call_result (fbr, 0x5176fbf25dcf50f4ULL, 0x4d7ae8b51fb816b5ULL);
  rb <<= rval;
  return &rb;
}
static Aida::ProtoMsg*
__aida_set__ButtonArea__on_click3 (Aida::ProtoReader &fbr)
{
  AIDA_ASSERT_RETURN (fbr.remaining() == 3 + 1 + 1, NULL);
  I_ButtonAreaIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_ASSERT_RETURN (self != NULL, NULL);
  std::string  arg_on_click3;
  fbr >>= arg_on_click3;
  self->on_click3 (arg_on_click3);
  return NULL;
}
static Aida::ProtoMsg*
__aida_get__ButtonArea__click_type (Aida::ProtoReader &fbr)
{
  AIDA_ASSERT_RETURN (fbr.remaining() == 3 + 1, NULL);
  I_ButtonAreaIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_ASSERT_RETURN (self != NULL, NULL);
  ClickType rval = self->click_type ();
  Aida::ProtoMsg &rb = *__AIDA_Local__::new_call_result (fbr, 0xb6ab79b43e1f0df9ULL, 0xaa0f1ec5c39b704aULL);
  rb <<= rval;
  return &rb;
}
static Aida::ProtoMsg*
__aida_set__ButtonArea__click_type (Aida::ProtoReader &fbr)
{
  AIDA_ASSERT_RETURN (fbr.remaining() == 3 + 1 + 1, NULL);
  I_ButtonAreaIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_ASSERT_RETURN (self != NULL, NULL);
  ClickType  arg_click_type;
  fbr >>= arg_click_type;
  self->click_type (arg_click_type);
  return NULL;
}

static Aida::ProtoMsg*
__aida_call__PureMethods__pure_method (Aida::ProtoReader &fbr)
{
  AIDA_ASSERT_RETURN (fbr.remaining() == 3 + 1 + 1, NULL);
  I_PureMethodsIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_ASSERT_RETURN (self != NULL, NULL);
  double  arg_f;
  fbr >>= arg_f;
  int rval = self->pure_method (arg_f);
  Aida::ProtoMsg &rb = *__AIDA_Local__::new_call_result (fbr, 0xf196563f00b6d484ULL, 0x88b59c2ed0597dccULL);
  rb <<= rval;
  return &rb;
}

} // RapicornAidaTest

namespace Other {
static Aida::ProtoMsg*
__aida_call__NameTests__args_from_other_namespace (Aida::ProtoReader &fbr)
{
  AIDA_ASSERT_RETURN (fbr.remaining() == 3 + 1 + 3, NULL);
  I_NameTestsIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_ASSERT_RETURN (self != NULL, NULL);
  InterfaceTests::SrvT_QuickRecord  arg_qr;
  fbr >>= arg_qr;
  RapicornAidaTest::ClickType  arg_qe;
  fbr >>= arg_qe;
  OtherNamespace::SrvT_SomeRecord  arg_sr;
  fbr >>= arg_sr;
  self->args_from_other_namespace (arg_qr, arg_qe, arg_sr);
  return NULL;
}

} // Other

namespace BseTest {
static Aida::ProtoMsg*
__aida_get__Compressor__threshold (Aida::ProtoReader &fbr)
{
  AIDA_ASSERT_RETURN (fbr.remaining() == 3 + 1, NULL);
  I_CompressorIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_ASSERT_RETURN (self != NULL, NULL);
  double rval = self->threshold ();
  Aida::ProtoMsg &rb = *__AIDA_Local__::new_call_result (fbr, 0xdea15f2de1c3d8e3ULL, 0xe3fc9febf31cdc20ULL);
  rb <<= rval;
  return &rb;
}
static Aida::ProtoMsg*
__aida_set__Compressor__threshold (Aida::ProtoReader &fbr)
{
  AIDA_ASSERT_RETURN (fbr.remaining() == 3 + 1 + 1, NULL);
  I_CompressorIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_ASSERT_RETURN (self != NULL, NULL);
  double  arg_threshold;
  fbr >>= arg_threshold;
  self->threshold (arg_threshold);
  return NULL;
}
static Aida::ProtoMsg*
__aida_get__Compressor__ratio (Aida::ProtoReader &fbr)
{
  AIDA_ASSERT_RETURN (fbr.remaining() == 3 + 1, NULL);
  I_CompressorIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_ASSERT_RETURN (self != NULL, NULL);
  double rval = self->ratio ();
  Aida::ProtoMsg &rb = *__AIDA_Local__::new_call_result (fbr, 0xc61a8d739c7b963bULL, 0xca1ad4eeab1aa56eULL);
  rb <<= rval;
  return &rb;
}
static Aida::ProtoMsg*
__aida_set__Compressor__ratio (Aida::ProtoReader &fbr)
{
  AIDA_ASSERT_RETURN (fbr.remaining() == 3 + 1 + 1, NULL);
  I_CompressorIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_ASSERT_RETURN (self != NULL, NULL);
  double  arg_ratio;
  fbr >>= arg_ratio;
  self->ratio (arg_ratio);
  return NULL;
}


} // BseTest

namespace { namespace AIDA_CPP_PASTE (__aida_stubs, __COUNTER__) {
static const __AIDA_Local__::MethodEntry entries[] = {
  { 0xc3f858f5171056cbULL, 0x394e47a2bcd63e16ULL, MandatoryNamespace::__aida_call__FirstInterface__void_func, },
  { 0xf67db704b9d460d6ULL, 0xd4950feab697e61eULL, InterfaceTests::__aida_get__UIWidgetArea__dummy, },
  { 0x7aaf2f96f3042829ULL, 0x3d0391e5b72e7ba5ULL, InterfaceTests::__aida_set__UIWidgetArea__dummy, },
  { 0x58ba68f6b64584c9ULL, 0xa7d2686edb40f27aULL, InterfaceTests::__aida_get__UIWidgetArea__on_click, },
  { 0xf0025ec0fa66e3e2ULL, 0x880c10e8e6b57cfbULL, InterfaceTests::__aida_set__UIWidgetArea__on_click, },
  { 0xd0dd4c08ba5022c0ULL, 0xb1af31ca1ec7037aULL, InterfaceTests::__aida_call__UIWidgetArea__simple_method, },
  { 0xe4e890540b4c0579ULL, 0xe14a7ffaa82f1c4fULL, InterfaceTests::__aida_call__UIWidgetArea__single_arg, },
  { 0x9cfaa316ccbb6ea0ULL, 0x6cc5207c5520e081ULL, InterfaceTests::__aida_call__UIWidgetArea__single_arg2, },
  { 0x64511c410b16c274ULL, 0x19b47eb22b4cd4d4ULL, InterfaceTests::__aida_call__UIWidgetArea__two_args, },
  { 0x2089150ae3f7ad80ULL, 0xe6154471cb4560e0ULL, InterfaceTests::__aida_call__UIWidgetArea__two_args2, },
  { 0x349f073a5bad36fdULL, 0xf7a10ae13b8e391bULL, InterfaceTests::__aida_call__UIWidgetArea__multi_args, },
  { 0x4b479b2f4e3ba551ULL, 0xb7c407eee57eb21aULL, InterfaceTests::__aida_call__UIWidgetArea__self_method, },
  { 0xdbb304ad4df15873ULL, 0xca276abf2bb1603cULL, InterfaceTests::__aida_call__UIWidgetArea__void_method, },
  { 0xb8bc20394724087aULL, 0xbc7b1e7d30aeb178ULL, InterfaceTests::__aida_call__UIWidgetArea__on_click2out, },
  { 0x3432c3bb41bc72a0ULL, 0x533bc22135f973bfULL, InterfaceTests::__aida_call__UIWidgetArea__on_click2in, },
  { 0x76ac7a704663d246ULL, 0x23abac49621c6802ULL, InterfaceTests::__aida_call__QuickIface__simple_function, },
  { 0x1addfccb0a3e01beULL, 0x314f2eb467d7a72bULL, InterfaceTests::__aida_call__MethodTestInterface__method_with_void, },
  { 0x55291a7348d14242ULL, 0x32dac90dde65a764ULL, InterfaceTests::__aida_call__MethodTestInterface__method_with_bools, },
  { 0xdc38cf6855c54108ULL, 0x328ddcdcec8f161eULL, InterfaceTests::__aida_call__MethodTestInterface__method_with_ints32, },
  { 0x678de8636167b6a1ULL, 0xb27d37ca066b5335ULL, InterfaceTests::__aida_call__MethodTestInterface__method_with_ints64, },
  { 0xeea6d5fb184699a3ULL, 0xce05c988a9bfd2d9ULL, InterfaceTests::__aida_call__MethodTestInterface__method_with_floats, },
  { 0x646f80849d732dc5ULL, 0x72fd1ede45b153e3ULL, InterfaceTests::__aida_call__MethodTestInterface__method_with_string, },
  { 0xee3b0b1c6eb52bdeULL, 0x13729d2db240b4f9ULL, InterfaceTests::__aida_call__MethodTestInterface__method_with_enum, },
  { 0x852c7f5942a87cceULL, 0x487dc78cd38240f6ULL, InterfaceTests::__aida_call__MethodTestInterface__method_with_record, },
  { 0x5534838e08bdc63dULL, 0xd852fd5abb88ab7dULL, InterfaceTests::__aida_call__MethodTestInterface__method_with_sequence, },
  { 0xfe9af28dc9c5de7dULL, 0x418be0c0e085ea6dULL, InterfaceTests::__aida_call__MethodTestInterface__method_with_interface, },
  { 0x807e5dacf307a277ULL, 0x2b65069e50e63c80ULL, InterfaceTests::__aida_call__MethodTestInterface__method_with_anys, },
  { 0xbe67f4e0afeafd68ULL, 0x5cdf24c075b03215ULL, InterfaceTests::__aida_call__MethodTestInterface__method_with_quickiface, },
  { 0x14469c03fdfc61e4ULL, 0x3bb8a3b5d9832788ULL, InterfaceTests::__aida_get__PropertyTester__bool_prop, },
  { 0xa88d7a16adc7ad43ULL, 0x33e7a32598f08880ULL, InterfaceTests::__aida_set__PropertyTester__bool_prop, },
  { 0x8a2f1538f2b852fbULL, 0x7d3e8ea6f069a1c0ULL, InterfaceTests::__aida_get__PropertyTester__int32_prop, },
  { 0x7b7b3182160469e4ULL, 0xbd3c44c3a57484ebULL, InterfaceTests::__aida_set__PropertyTester__int32_prop, },
  { 0xc9bb6114fc5c90deULL, 0x400dff0f59e66f63ULL, InterfaceTests::__aida_get__PropertyTester__int64_prop, },
  { 0xb33bf89d2259a1dbULL, 0x0154420aebe9a16cULL, InterfaceTests::__aida_set__PropertyTester__int64_prop, },
  { 0xb3d53f6a66ba171eULL, 0xc9e2fe1ad9d2d2abULL, InterfaceTests::__aida_get__PropertyTester__float64_prop, },
  { 0xf1df5bd296ac78e2ULL, 0xbb263cff89927093ULL, InterfaceTests::__aida_set__PropertyTester__float64_prop, },
  { 0xd11acce29fa83acfULL, 0xb251b5fc0f737558ULL, InterfaceTests::__aida_get__PropertyTester__string_prop, },
  { 0xfadb1eed1d8d358aULL, 0x17cd2ca684080698ULL, InterfaceTests::__aida_set__PropertyTester__string_prop, },
  { 0x42f93106aeb5af11ULL, 0xdc4094dc01da9f81ULL, InterfaceTests::__aida_get__PropertyTester__enum_prop, },
  { 0x99206fff699c82d6ULL, 0x1dcbc77498569411ULL, InterfaceTests::__aida_set__PropertyTester__enum_prop, },
  { 0xb6ab96740d7834eeULL, 0xe7873bec722bb0c8ULL, InterfaceTests::__aida_get__PropertyTester__record_prop, },
  { 0x55aaf8cee9dd7a46ULL, 0x83d8416416740bf0ULL, InterfaceTests::__aida_set__PropertyTester__record_prop, },
  { 0x7f96e6ff442ecdd5ULL, 0xdb054c03831fd75bULL, InterfaceTests::__aida_get__PropertyTester__sequence_prop, },
  { 0xf86952a034b8bc84ULL, 0x3be169a3f0a9a07dULL, InterfaceTests::__aida_set__PropertyTester__sequence_prop, },
  { 0xf3cef8a00677d931ULL, 0x8733ca529b58ea4aULL, InterfaceTests::__aida_get__PropertyTester__interface_prop, },
  { 0xbf62779e2a11aebbULL, 0x95547f4e29ca3814ULL, InterfaceTests::__aida_set__PropertyTester__interface_prop, },
  { 0xdd2a04f6c2fc3005ULL, 0x68868b01ea78948fULL, InterfaceTests::__aida_get__PropertyTester__self_prop, },
  { 0x1a1ee3ab20ab3c2fULL, 0xeeaf17826dba2891ULL, InterfaceTests::__aida_set__PropertyTester__self_prop, },
  { 0xb54c6ac2d1c8f932ULL, 0x1c8ea2813f2c268eULL, InterfaceTests::__aida_get__PropertyTester__any_prop, },
  { 0xe0c7d397e652f3f7ULL, 0xbbdf7826e88f4f42ULL, InterfaceTests::__aida_set__PropertyTester__any_prop, },
  { 0x199859aecc756e97ULL, 0xa744332174ed27f4ULL, RapicornAidaTest::__aida_get__ButtonArea__on_click, },
  { 0xdb3a24116c653985ULL, 0x2a0576faff45b4b2ULL, RapicornAidaTest::__aida_set__ButtonArea__on_click, },
  { 0x1b448d91990181daULL, 0x9751c08ae956c729ULL, RapicornAidaTest::__aida_get__ButtonArea__on_click2, },
  { 0xfc93898ba4104662ULL, 0xc918694fe5c2bfefULL, RapicornAidaTest::__aida_set__ButtonArea__on_click2, },
  { 0x5176fbf25dcf50f4ULL, 0x4d7ae8b51fb816b5ULL, RapicornAidaTest::__aida_get__ButtonArea__on_click3, },
  { 0x1c1990dca0fde97cULL, 0x6cc2c7cc49d811f8ULL, RapicornAidaTest::__aida_set__ButtonArea__on_click3, },
  { 0xb6ab79b43e1f0df9ULL, 0xaa0f1ec5c39b704aULL, RapicornAidaTest::__aida_get__ButtonArea__click_type, },
  { 0x1f5a6d031cb7e104ULL, 0x2d4a207f0842bec8ULL, RapicornAidaTest::__aida_set__ButtonArea__click_type, },
  { 0xf196563f00b6d484ULL, 0x88b59c2ed0597dccULL, RapicornAidaTest::__aida_call__PureMethods__pure_method, },
  { 0xd471f88e8c15081cULL, 0x963d2094339d0220ULL, Other::__aida_call__NameTests__args_from_other_namespace, },
  { 0xdea15f2de1c3d8e3ULL, 0xe3fc9febf31cdc20ULL, BseTest::__aida_get__Compressor__threshold, },
  { 0xf40a3fd3d07b3d0bULL, 0xbae97c41e3d6a92bULL, BseTest::__aida_set__Compressor__threshold, },
  { 0xc61a8d739c7b963bULL, 0xca1ad4eeab1aa56eULL, BseTest::__aida_get__Compressor__ratio, },
  { 0x302f0b5b99a2a6c8ULL, 0xc8b771894ecd9315ULL, BseTest::__aida_set__Compressor__ratio, },
};
static __AIDA_Local__::MethodRegistry registry (entries);
} } // anon::__aida_stubs##__COUNTER__

static_assert (Aida::TypeHash { AIDA_HASH___TYPENAME__ } ==
               Aida::TypeHash { 0x51cded9001a397cfULL, 0xb54ad82e7dba3ecdULL },
               "Expecting hash defined as:\n#define AIDA_HASH___TYPENAME__ 	0x51cded9001a397cfULL, 0xb54ad82e7dba3ecdULL");
static_assert (Aida::TypeHash { AIDA_HASH___AIDA_TYPELIST__ } ==
               Aida::TypeHash { 0x7e82df289d876d3fULL, 0xf8f5d4684116729cULL },
               "Expecting hash defined as:\n#define AIDA_HASH___AIDA_TYPELIST__ 	0x7e82df289d876d3fULL, 0xf8f5d4684116729cULL");
static_assert (Aida::TypeHash { AIDA_HASH___AIDA_AUX_DATA__ } ==
               Aida::TypeHash { 0x42fc748a3a55dc79ULL, 0x04053ea3795243f7ULL },
               "Expecting hash defined as:\n#define AIDA_HASH___AIDA_AUX_DATA__ 	0x42fc748a3a55dc79ULL, 0x04053ea3795243f7ULL");
static_assert (Aida::TypeHash { AIDA_HASH___AIDA_DIR__ } ==
               Aida::TypeHash { 0xa35c47733d813815ULL, 0x25c2ae6cf0d91567ULL },
               "Expecting hash defined as:\n#define AIDA_HASH___AIDA_DIR__ 	0xa35c47733d813815ULL, 0x25c2ae6cf0d91567ULL");
static_assert (Aida::TypeHash { AIDA_HASH___AIDA_GET__ } ==
               Aida::TypeHash { 0x4aed20bb93591defULL, 0xc75b192eab6983edULL },
               "Expecting hash defined as:\n#define AIDA_HASH___AIDA_GET__ 	0x4aed20bb93591defULL, 0xc75b192eab6983edULL");
static_assert (Aida::TypeHash { AIDA_HASH___AIDA_SET__ } ==
               Aida::TypeHash { 0x9b7396e68c10cd21ULL, 0x2d19eea7536aa1b9ULL },
               "Expecting hash defined as:\n#define AIDA_HASH___AIDA_SET__ 	0x9b7396e68c10cd21ULL, 0x2d19eea7536aa1b9ULL");
static_assert (Aida::TypeHash { AIDA_HASH___EVENT_ATTACH__ } ==
               Aida::TypeHash { 0xbfceda11a8b5f5f6ULL, 0x2848342815fe5acbULL },
               "Expecting hash defined as:\n#define AIDA_HASH___EVENT_ATTACH__ 	0xbfceda11a8b5f5f6ULL, 0x2848342815fe5acbULL");
static_assert (Aida::TypeHash { AIDA_HASH___EVENT_DETACHID__ } ==
               Aida::TypeHash { 0xd6c0b4477875ecc4ULL, 0x7ddefe71b4272a9bULL },
               "Expecting hash defined as:\n#define AIDA_HASH___EVENT_DETACHID__ 	0xd6c0b4477875ecc4ULL, 0x7ddefe71b4272a9bULL");
static_assert (Aida::TypeHash { AIDA_HASH___EVENT_CALLBACK__ } ==
               Aida::TypeHash { 0x74d6b010e16cff95ULL, 0x71917df9fae9c99fULL },
               "Expecting hash defined as:\n#define AIDA_HASH___EVENT_CALLBACK__ 	0x74d6b010e16cff95ULL, 0x71917df9fae9c99fULL");
